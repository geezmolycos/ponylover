<html>
    <head>
        <title>爱我的六色马可以做什么事</title>
        <meta charset="UTF-8">
	    <script
            src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
            crossorigin="anonymous"></script>
        <style>
            :root {
                --game-grid-size: 34px;
                --game-grid-border: 2px;
            }

            .layer-cont{
                position: relative;
            }
            .sublayer-cont{
                position: absolute;
                left: 0px;
                top: 0px;
            }
            .cell-wrapper{
                display: inline-block;
                width: var(--game-grid-size);
                height: var(--game-grid-size);
                box-sizing: border-box;
                padding-top: var(--game-grid-border);
                padding-left: var(--game-grid-border);
                image-rendering: pixelated;
            }
            .grid-cont{
                border-bottom: var(--game-grid-border) solid black;
                border-right: var(--game-grid-border) solid black;
                position: static;
                display: inline-block;
            }
            .grid-cont .cell-wrapper{
                border-top: var(--game-grid-border) solid black;
                border-left: var(--game-grid-border) solid black;
                padding-top: 0px;
                padding-left: 0px;
            }
        </style>
    </head>
    <body>
        <div>
            <button id="advance">advance</button>
            <button id="stop">stop</button>
            <span id="time">0</span>
        </div>
        <script>
            'use strict'

            const cardinal = [[0, -1], [-1, 0], [1, 0], [0, 1]];

            class EmptyEnt{
                can_place_item_on(inst){return true;}
                can_be_moved(inst){return true;}
                tick(inst){}
                draw(inst){}
                info(inst){return '什么也没有';}
                enum_states(){
                    return [];
                }
                init_other_states(state){}
            }

            function entity_dir_source(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x - dx, inst.y - dy];
                return [tx, ty];
            }

            function entity_dir_target(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x + dx, inst.y + dy];
                return [tx, ty];
            }

            function entity_output_item(inst, tx, ty, item_type, item_state){
                if (inst.layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                    || inst.layer.get_item_changed(tx, ty)
                    || !inst.layer.can_place_item_on(tx, ty)){
                    return false;
                }
                inst.layer.next_item_sublayer.swap(tx, ty, item_type, item_state);
                inst.layer.set_item_changed(tx, ty, true);
                return true;
            }

            function entity_output_two_items(inst, txa, tya, txb, tyb, item_type_a, item_state_a, item_type_b, item_state_b){
                for (let [tx, ty] of [[txa, tya], [txb, tyb]]){
                    if (inst.layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                        || inst.layer.get_item_changed(tx, ty)
                        || !inst.layer.can_place_item_on(tx, ty)){
                        return false;
                    }
                }
                inst.layer.next_item_sublayer.swap(txa, tya, item_type_a, item_state_a);
                inst.layer.set_item_changed(txa, tya, true);
                inst.layer.next_item_sublayer.swap(txb, tyb, item_type_b, item_state_b);
                inst.layer.set_item_changed(txb, tyb, true);
                return true;
            }

            class BeltEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    let [tx, ty] = entity_dir_target(inst);
                    if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                        inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                        inst.layer.set_item_changed(inst.x, inst.y, true);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){return '传送带'}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){}
            }

            class LadderEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    let tx = inst.x;
                    let ty = inst.y;
                    if (inst.layer.ladder_layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                        || inst.layer.ladder_layer.get_item_changed(tx, ty)
                        || !inst.layer.ladder_layer.can_place_item_on(tx, ty)){
                        return;
                    }
                    inst.layer.ladder_layer.next_item_sublayer.swap(tx, ty, old_item_inst.type, old_item_inst.state);
                    inst.layer.ladder_layer.set_item_changed(tx, ty, true);
                    inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                    inst.layer.set_item_changed(inst.x, inst.y, true);
                }
                draw(inst){
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [];
                }
                init_other_states(state){}
            }

            class RouterEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let tick_time = Math.floor(inst.layer.time / this.delay);
                    let leftup = tick_time % 6 === 0 || tick_time % 6 === 1 || tick_time % 6 === 4;
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);

                    let tx = inst.x;
                    let ty = inst.y;
                    if (inst.state.hv === 0){
                        tx += leftup ? -1 : 1;
                    } else {
                        ty += leftup ? -1 : 1;
                    }
                    if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                        inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                        inst.layer.set_item_changed(inst.x, inst.y, true);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '90deg'][inst.state.hv];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['hv', [0, 1]]
                    ];
                }
                init_other_states(state){}
            }

            class FilterEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    
                    if (!inst.state.filter_inited){
                        inst.state.filter_inited = true;
                        inst.state.filter_item_type = inst.layer.item_sublayer.get_inst(inst.x, inst.y).type;
                        return;
                    }

                    let tick_time = Math.floor(inst.layer.time / this.delay);
                    let leftup = tick_time % 6 === 0 || tick_time % 6 === 1 || tick_time % 6 === 4;
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    if (old_item_inst.type === inst.state.filter_item_type){
                        let [tx, ty] = entity_dir_target(inst);
                        if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                            inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                            inst.layer.set_item_changed(inst.x, inst.y, true);
                        }
                    } else {
                        let tx = inst.x;
                        let ty = inst.y;
                        if (inst.state.hv === 0){
                            tx += leftup ? -1 : 1;
                        } else {
                            ty += leftup ? -1 : 1;
                        }
                        if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                            inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                            inst.layer.set_item_changed(inst.x, inst.y, true);
                        }
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0, 1, 2, 3]]
                    ];
                }
                init_other_states(state){
                    state.filter_inited = false;
                    state.filter_item_type = null;
                }
            }


            class MachineEnt extends EmptyEnt{
                constructor(ingredient_f, amounts, product_type, product_state, product_amount, cooldown_ticks){
                    super();
                    this.ingredient_f = ingredient_f;
                    this.amounts = amounts;
                    this.product_type = product_type;
                    this.product_state = product_state;
                    this.product_amount = product_amount;
                    this.cooldown_ticks = cooldown_ticks;
                }
                can_place_item_on(inst){return false;}
                check_fulfill(inst){
                    if (inst.state.fulfilled){
                        return true;
                    }
                    let fulfilled = true;
                    $.each(this.amounts, (i, val) => {
                        if (inst.state.current_amounts[i] < val){
                            fulfilled = false;
                            return false;
                        }
                    });
                    return fulfilled;
                }
                tick(inst){
                    if (inst.state.remaining_output > 0){
                        let [tx, ty] = entity_dir_target(inst);
                        if (entity_output_item(inst, tx, ty, this.product_type, this.product_state)){
                            inst.state.remaining_output--;
                            if (inst.state.remaining_output == 0){
                                this.init_other_states(inst.state);
                            }
                        }
                        return;
                    }
                    if (inst.state.cooldown_ticks > 0){
                        inst.state.cooldown_ticks--;
                        return;
                    }
                    let [sx, sy] = entity_dir_source(inst);
                    if (inst.layer.get_item_changed(sx, sy)
                        || inst.layer.item_sublayer.get_inst(sx, sy).type === item_table.get('empty')){
                        return;
                    }
                    let ingredient_i = this.ingredient_f(
                        inst.layer.item_sublayer.get_inst(sx, sy).type,
                        inst.layer.item_sublayer.get_inst(sx, sy).state
                    )
                    if (ingredient_i === -1){
                        return;
                    }
                    inst.state.current_amounts[ingredient_i]++;
                    inst.layer.next_item_sublayer.swap(sx, sy, item_table.get('empty'), null);
                    inst.layer.set_item_changed(sx, sy, true);
                    if (this.check_fulfill(inst)){
                        inst.state.fulfilled = true;
                        inst.state.remaining_output = this.product_amount;
                        inst.state.cooldown_ticks = this.cooldown_ticks;
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){
                    state.fulfilled = false;
                    state.remaining_output = 0;
                    state.current_amounts = new Array(this.amounts.length).fill(0);
                    state.cooldown_ticks = 0;
                }
            }

            class TwoOutputMachineEnt extends EmptyEnt{
                constructor(ingredient_f, amounts, product_type_a, product_state_a, product_amount_a, product_type_b, product_state_b, product_amount_b){
                    super();
                    this.ingredient_f = ingredient_f;
                    this.amounts = amounts;
                    this.product_type_a = product_type_a;
                    this.product_state_a = product_state_a;
                    this.product_amount_a = product_amount_a;
                    this.product_type_b = product_type_b;
                    this.product_state_b = product_state_b;
                    this.product_amount_b = product_amount_b;
                }
                can_place_item_on(inst){return false;}
                check_fulfill(inst){
                    if (inst.state.fulfilled){
                        return true;
                    }
                    let fulfilled = true;
                    $.each(this.amounts, (i, val) => {
                        if (inst.state.current_amounts[i] < val){
                            fulfilled = false;
                            return false;
                        }
                    });
                    return fulfilled;
                }
                hv(inst){
                    return inst.state.dir === 0 || inst.state.dir === 3 ? 1 : 0;
                }
                tick(inst){
                    if (inst.state.remaining_output_a > 0 || inst.state.remaining_output_b > 0){
                        let [txa, tya, txb, tyb] = [inst.x, inst.y, inst.x, inst.y];
                        if (this.hv(inst) === 0){
                            txa--; txb++;
                        } else {
                            tya--; tyb++;
                        }
                        if (inst.state.remaining_output_a > 0){
                            if (entity_output_item(inst, txa, tya, this.product_type_a, this.product_state_a)){
                                inst.state.remaining_output_a--;
                                if (inst.state.remaining_output_a == 0 && inst.state.remaining_output_b == 0){
                                    this.init_other_states(inst.state);
                                }
                            }
                        }
                        if (inst.state.remaining_output_b > 0){
                            if (entity_output_item(inst, txb, tyb, this.product_type_b, this.product_state_b)){
                                inst.state.remaining_output_a--;
                                if (inst.state.remaining_output_a == 0 && inst.state.remaining_output_b == 0){
                                    this.init_other_states(inst.state);
                                }
                            }
                        }
                        return;
                    }

                    if (inst.state.cooldown_ticks > 0){
                        inst.state.cooldown_ticks--;
                        return;
                    }
                    
                    let [sx, sy] = entity_dir_source(inst);
                    if (inst.layer.get_item_changed(sx, sy)
                        || inst.layer.item_sublayer.get_inst(sx, sy).type === item_table.get('empty')){
                        return;
                    }
                    let ingredient_i = this.ingredient_f(
                        inst.layer.item_sublayer.get_inst(sx, sy).type,
                        inst.layer.item_sublayer.get_inst(sx, sy).state
                    )
                    if (ingredient_i === -1){
                        return;
                    }
                    inst.state.current_amounts[ingredient_i]++;
                    inst.layer.next_item_sublayer.swap(sx, sy, item_table.get('empty'), null);
                    inst.layer.set_item_changed(sx, sy, true);
                    if (this.check_fulfill(inst)){
                        inst.state.fulfilled = true;
                        inst.state.remaining_output_a = this.product_amount_a;
                        inst.state.remaining_output_b = this.product_amount_b;
                        inst.state.cooldown_ticks = this.cooldown_ticks;
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){
                    state.fulfilled = false;
                    state.remaining_output_a = 0;
                    state.remaining_output_b = 0;
                    state.current_amounts = new Array(this.amounts.length).fill(0);
                    state.cooldown_ticks = 0;
                }
            }

            class EmptyItem{
                draw(inst){}
                info(inst){}
                as_crafting_ingredient(inst){
                    return [inst.type, 1];
                }
            }

            class IconItem extends EmptyItem{
                constructor(icon, pos_x, pos_y){
                    super();
                    this.icon = icon;
                    this.pos_x = pos_x;
                    this.pos_y = pos_y;
                }
                draw(inst){
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`)
                        .css('width', '100%').css('height', '100%');
                }
                info(inst){}
            }

            let item_table = new Map([
                ['empty', new EmptyItem()],
                ['crop', new IconItem("./texture.png", 0, 0)],
                ['food', new IconItem("./texture.png", 1, 0)],
                ['coal', new IconItem("./texture.png", 2, 0)],
                ['iron_ore', new IconItem("./texture.png", 3, 0)],
                ['uran_ore', new IconItem("./texture.png", 4, 0)],
                ['iron_ingot', new IconItem("./texture.png", 3, 1)],
                ['uran_ingot', new IconItem("./texture.png", 4, 1)],
                ['anti_iron_ingot', new IconItem("./texture.png", 3, 2)],
                ['lead_ingot', new IconItem("./texture.png", 4, 2)],
                ['fire', new IconItem("./texture.png", 0, 4)],
                ['light', new IconItem("./texture.png", 1, 4)],
                ['elec', new IconItem("./texture.png", 2, 4)],
                ['wormhole', new IconItem("./texture.png", 4, 4)],
            ]);

            let entity_table = new Map([
                ['empty', new EmptyEnt()],
                ['belt', (()=>{let e = new BeltEnt(5); e.icon='./texture.png'; e.pos_x=0; e.pos_y=6; return e})()],
                ['fast_belt', (()=>{let e = new BeltEnt(3); e.icon='./texture.png'; e.pos_x=1; e.pos_y=6; return e})()],
                ['faster_belt', (()=>{let e = new BeltEnt(1); e.icon='./texture.png'; e.pos_x=2; e.pos_y=6; return e})()],
                ['ladder', (()=>{let e = new LadderEnt(5); e.icon='./texture.png'; e.pos_x=0; e.pos_y=7; return e})()],
                ['router', (()=>{let e = new RouterEnt(5); e.icon='./texture.png'; e.pos_x=1; e.pos_y=7; return e})()],
                ['filter', (()=>{let e = new FilterEnt(5); e.icon='./texture.png'; e.pos_x=2; e.pos_y=7; return e})()],
                ['gravity_gen', (()=>{
                    let e = new MachineEnt((type, state)=>(-1), [1], item_table.get('elec'), null, 6, 100);
                    e.icon='./texture.png'; e.pos_x=2; e.pos_y=7; return e
                })()],
            ]);

            class YardSubLayer{
                constructor(layer, init_val){
                    this.layer = layer;
                    this.empty(init_val);
                }

                swap(x, y, new_type, new_state){
                    const i = this.layer.xy2i(x, y);
                    const old_type = this.type[i];
                    const old_state = this.state.get(i) || null;
                    this.state.delete(i);
                    this.type[i] = new_type;
                    if (new_state !== null){
                        this.state.set(i, new_state);
                    }
                    return [old_type, old_state];
                }

                make_cont(){
                    let $sublayer_cont = $('<div>').addClass('sublayer-cont');
                    for (let y=0; y<this.layer.height; y++){
                        for (let x=0; x<this.layer.width; x++){
                            const wrapper = $('<div>').addClass('cell-wrapper').data('x', x).data('y', y);
                            $sublayer_cont.append(wrapper);
                        }
                        $sublayer_cont.append($('<br>'));
                    }
                    return $sublayer_cont;
                }

                get_inst(x, y){
                    let state = this.state.get(this.layer.xy2i(x, y)) || null;
                    let type = this.type[this.layer.xy2i(x, y)];
                    return {
                        layer: this.layer,
                        x: x,
                        y: y,
                        type: type,
                        state: state,
                    }
                }

                draw_all($sublayer_cont){
                    let that = this;
                    $sublayer_cont.children('.cell-wrapper').each((_, wrapper)=>{
                        let $wrapper = $(wrapper);
                        const x = $wrapper.data('x');
                        const y = $wrapper.data('y');
                        $wrapper.empty();
                        let inst = that.get_inst(x, y);
                        let c = inst.type.draw(inst);
                        $wrapper.append(c);
                    });
                }


                empty(init_val){
                    this.type = new Array(this.layer.width * this.layer.height).fill(init_val);
                    this.state = new Map();
                }
            }

            class YardLayer{
                constructor(width, height){
                    this.width = width;
                    this.height = height;
                    this.entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.next_entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.entity_changed = new Array(this.width * this.height).fill(false);
                    this.item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.next_item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.item_changed = new Array(this.width * this.height).fill(false);
                    this.time = 0;
                }

                get_entity_changed(x, y){
                    return this.entity_changed[this.xy2i(x, y)];
                }
                
                set_entity_changed(x, y, val){
                    this.entity_changed[this.xy2i(x, y)] = val;
                }

                get_item_changed(x, y){
                    return this.item_changed[this.xy2i(x, y)];
                }

                set_item_changed(x, y, val){
                    this.item_changed[this.xy2i(x, y)] = val;
                }

                can_place_item_on(x, y){
                    if (!this.is_in_border(x, y)){
                        return false;
                    }
                    let inst = this.entity_sublayer.get_inst(x, y);
                    let ninst = this.next_entity_sublayer.get_inst(x, y);
                    return inst.type.can_place_item_on(inst) && ninst.type.can_place_item_on(ninst);
                }

                xy2i(x, y){
                    return this.width * y + x;
                }

                i2xy(i){
                    return [i % this.width, Math.floor(i / this.width)];
                }

                is_in_border(x, y){
                    return 0 <= x && x < this.width && 0 <= y && y < this.height;
                }

                do_tick_reversed(){
                    return this.time % 4 < 2;
                }

                tick_all(){
                    if (this.do_tick_reversed()){
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(this.width - x - 1, this.height - y - 1);
                            }
                        }
                    } else {
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(x, y);
                            }
                        }
                    }
                    this.item_sublayer.type = [...this.next_item_sublayer.type];
                    this.item_sublayer.state = new Map(this.next_item_sublayer.state);
                    this.item_changed.fill(false);
                    this.entity_sublayer.type = [...this.next_entity_sublayer.type];
                    this.entity_sublayer.state = new Map(this.next_entity_sublayer.state);
                    this.entity_changed.fill(false);
                    this.time++;
                }

                tick_at(x, y){
                    let inst = this.entity_sublayer.get_inst(x, y);
                    inst.type.tick(inst);
                }

                on_mouse_place_entity(inst){
                    return {
                        able: true,
                        type: entity_table.get('empty'),
                        state: null
                    };
                }

                make_cont(){
                    let $cont = $('<div>').addClass('layer-cont');
                    let $grid_cont = this.entity_sublayer.make_cont().addClass('grid-cont');
                    let $entity_cont = this.entity_sublayer.make_cont().addClass('entity-sublayer-cont');
                    let $item_cont = this.item_sublayer.make_cont().addClass('item-sublayer-cont');
                    let $mouseclick_cont = this.entity_sublayer.make_cont().addClass('mouseclick-cont');
                    $mouseclick_cont.children('.cell-wrapper').on('click', (e)=>{
                        let x = $(e.target).data('x');
                        let y = $(e.target).data('y');
                        let inst = this.next_entity_sublayer.get_inst(x, y);
                        let res = this.on_mouse_place_entity(inst);
                        if (!res.able){
                            return;
                        }
                        this.next_entity_sublayer.swap(x, y, res.type, res.state);
                    });
                    $cont.append($grid_cont).append($entity_cont).append($item_cont).append($mouseclick_cont);
                    return $cont;
                }

                draw_all($layer_cont){
                    let $entity_cont = $layer_cont.children('.entity-sublayer-cont');
                    let $item_cont = $layer_cont.children('.item-sublayer-cont');
                    this.next_entity_sublayer.draw_all($entity_cont);
                    this.next_item_sublayer.draw_all($item_cont);
                }
            }
        
            let ground_layer = new YardLayer(10, 5);
            let underground_layer = new YardLayer(10, 5);
            ground_layer.ladder_layer = underground_layer;
            underground_layer.ladder_layer = ground_layer;

            ground_layer.on_mouse_place_entity = underground_layer.on_mouse_place_entity = (inst)=>{
                if (!inst.type.can_be_moved(inst)){
                    return {
                        able: false
                    };
                }
                let [swap_out_type, swap_out_state] = inst.layer.hand_layer.next_entity_sublayer.swap(0, 0, inst.type, inst.state);
                redraw_hand_and_selector();
                return {
                    able: true,
                    type: swap_out_type,
                    state: swap_out_state
                };
            }
            
            let $layer_cont = ground_layer.make_cont();
            let $underground_layer_cont = underground_layer.make_cont();
            $('body').append($layer_cont);
            $('body').append($underground_layer_cont);

            let hand_layer = new YardLayer(1, 1);
            hand_layer.get_entity_inst = function(){
                return this.next_entity_sublayer.get_inst(0, 0);
            }
            hand_layer.get_item_inst = function(){
                return this.next_item_sublayer.get_inst(0, 0);
            }
            let $hand_layer_cont = hand_layer.make_cont();
            $('body').append($hand_layer_cont);
            ground_layer.hand_layer = hand_layer;
            underground_layer.hand_layer = hand_layer;

            let $state_selector_cont = $('<div>').addClass('state-selector-cont');
            $state_selector_cont.append($('<div>').addClass('item-info'));
            $state_selector_cont.append($('<div>').addClass('item-debug-state'));
            $state_selector_cont.append($('<div>').addClass('state-enum'));
            let selector_layer = new YardLayer(8, 3);
            let $selector_layer_cont = selector_layer.make_cont();
            $state_selector_cont.children('.state-enum').append($selector_layer_cont);
            $('body').append($state_selector_cont);

            selector_layer.on_mouse_place_entity = (inst)=>{
                if (inst.type === entity_table.get('empty')){
                    return {
                        able: false
                    };
                }
                let [swap_out_type, swap_out_state] = hand_layer.next_entity_sublayer.swap(0, 0, inst.type, inst.state);
                redraw_hand_and_selector();
                return {
                    able: false
                };
            }

            function redraw_hand_and_selector(){
                hand_layer.draw_all($hand_layer_cont);
                let entity_inst = hand_layer.get_entity_inst();
                let info = entity_inst.type.info(entity_inst);
                $state_selector_cont.children('.item-info').empty();
                $state_selector_cont.children('.item-info').append(info);
                $state_selector_cont.children('.item-debug-state').empty();
                $state_selector_cont.children('.item-debug-state').append(JSON.stringify(entity_inst.state));
                let enum_states = entity_inst.type.enum_states();
                let x=0, y=0;
                selector_layer.next_entity_sublayer.empty(entity_table.get('empty'));
                let trimmed_state = {};
                for (let [state_key, state_values] of enum_states){
                    trimmed_state[state_key] = entity_inst.state[state_key];
                }
                entity_inst.type.init_other_states(trimmed_state);
                for (let [state_key, state_values] of enum_states){
                    for (let v of state_values){
                        let new_state = structuredClone(trimmed_state);
                        new_state[state_key] = v;
                        selector_layer.next_entity_sublayer.swap(x, y, entity_inst.type, new_state);
                        x++;
                    }
                    y++
                }
                selector_layer.draw_all($selector_layer_cont);
            }
            redraw_hand_and_selector();

            let crafting_layer = new YardLayer(8, 4);

            let crafting_recipes = [
                {
                    in: [['elec', 1]],
                    out: 'belt'
                }
            ];
            let crafting_recipes_positioned = new Map();

            let ground_crafting_region = {
                xa: 0, ya: 0, xb: 3, yb: 2
            }

            function get_default_state(entity_type){
                let state = {};
                for (let [state_key, values] of entity_type.enum_states()){
                    state[state_key] = values[0];
                }
                entity_type.init_other_states(state);
                return state;
            }

            function put_crafting(){
                let x = 0, y = 0;
                for (let recipe of crafting_recipes){
                    if (recipe.br){
                        y++;
                        continue;
                    }
                    crafting_recipes_positioned.set(crafting_layer.xy2i(x, y), recipe);
                    let out_type = entity_table.get(recipe.out);
                    crafting_layer.next_entity_sublayer.swap(x, y, out_type, get_default_state(out_type));
                    x++;
                    if (x >= crafting_layer.width){
                        y++;
                        x = 0;
                    }
                }
            }
            put_crafting();

            function can_craft(in_list, do_craft=false){
                let need_count = new Map();
                for (let [item_key, item_amount] of in_list){
                    need_count.set(item_table.get(item_key), item_amount);
                }
                for (let y=ground_crafting_region.ya; y<ground_crafting_region.yb; y++){
                    for (let x=ground_crafting_region.xa; x<ground_crafting_region.xb; x++){
                        let inst = ground_layer.next_item_sublayer.get_inst(x, y);
                        let [recipe_type, recipe_amount] = inst.type.as_crafting_ingredient(inst);
                        if (need_count.has(recipe_type)){
                            if (do_craft){
                                ground_layer.next_item_sublayer.swap(x, y, item_table.get('empty'), null);
                                ground_layer.set_item_changed(x, y, true);
                            }
                            let prev_amount = need_count.get(recipe_type);
                            if (prev_amount - recipe_amount < 0){ // too many ingredients in one item
                                continue;
                            }
                            need_count.set(recipe_type, prev_amount - recipe_amount);
                            if (need_count.get(recipe_type) == 0){
                                need_count.delete(recipe_type);
                                if (need_count.size == 0){
                                    return need_count;
                                }
                            }
                        }
                    }
                }
                return need_count;
            }

            crafting_layer.on_mouse_place_entity = function(inst){
                let i = inst.layer.xy2i(inst.x, inst.y);
                let recipe = crafting_recipes_positioned.get(i);
                if (hand_layer.next_entity_sublayer.get_inst(0, 0).type !== entity_table.get('empty')){
                    return {able: false};
                }
                if (can_craft(recipe.in).size == 0){
                    can_craft(recipe.in, true);
                    let out_type = entity_table.get(recipe.out);
                    hand_layer.next_entity_sublayer.swap(0, 0, out_type, get_default_state(out_type));
                    redraw_hand_and_selector();
                }
                return {able: false};
            }

            let $crafting_cont = crafting_layer.make_cont();
            $('body').append($crafting_cont);
            crafting_layer.draw_all($crafting_cont);


            ground_layer.next_item_sublayer.swap(1, 0, item_table.get('iron_ingot'), null);
            ground_layer.next_item_sublayer.swap(1, 1, item_table.get('iron_ingot'), null);
            ground_layer.next_item_sublayer.swap(0, 2, item_table.get('elec'), null);
            ground_layer.next_item_sublayer.swap(1, 2, item_table.get('iron_ingot'), null);
            ground_layer.next_item_sublayer.swap(1, 3, item_table.get('iron_ingot'), null);
            ground_layer.next_item_sublayer.swap(1, 4, item_table.get('iron_ingot'), null);
            ground_layer.next_entity_sublayer.swap(1, 0, entity_table.get('belt'), {dir: 3});
            ground_layer.next_entity_sublayer.swap(1, 1, entity_table.get('belt'), {dir: 3});
            ground_layer.next_entity_sublayer.swap(0, 2, entity_table.get('belt'), {dir: 2});
            ground_layer.next_entity_sublayer.swap(1, 3, entity_table.get('belt'), {dir: 0});
            ground_layer.next_entity_sublayer.swap(1, 4, entity_table.get('belt'), {dir: 0});
            ground_layer.next_entity_sublayer.swap(1, 2, entity_table.get('belt'), {dir: 2});
            ground_layer.next_entity_sublayer.swap(2, 2, entity_table.get('belt'), {dir: 2});
            ground_layer.next_entity_sublayer.swap(3, 2, entity_table.get('gravity_gen'), {dir: 2});
            let bi = ground_layer.next_entity_sublayer.get_inst(3, 2)
            bi.type.init_other_states(bi.state);
            ground_layer.next_entity_sublayer.swap(4, 2, entity_table.get('belt'), {dir: 3});
            ground_layer.next_entity_sublayer.swap(4, 3, entity_table.get('belt'), {dir: 3});
            ground_layer.next_entity_sublayer.swap(4, 4, entity_table.get('ladder'));
            ground_layer.next_entity_sublayer.swap(5, 4, entity_table.get('router'), {hv: 0});
            ground_layer.next_entity_sublayer.swap(6, 4, entity_table.get('filter'), {dir: 0, filter_inited:false, filter_item_type:null});
            ground_layer.draw_all($layer_cont);
            let ikk = -1;
            $('#advance').on('click', (e)=>{
                ikk = setInterval(()=>{
                    $("#time").text(ground_layer.time);
                    ground_layer.tick_all();
                    ground_layer.draw_all($layer_cont);
                    underground_layer.tick_all();
                    underground_layer.draw_all($underground_layer_cont);
                }, 50);
            });
            $('#stop').on('click', (e)=>{
                clearInterval(ikk);
            });
        </script>
        <script>
            /*
            剧情：一个人特别爱六只马(pony)，这是他家的电表发生的变化……
                为了穿越到六马的世界，他读了很多书，发现要扭曲空间，需要很多能量。因此他开始搭建生产线，产出能量。
            类factorio：
                资源：
                    - 固态：粮食、饭、煤、铁矿、铀矿
                        铁、铀、铅
                        反铁
                    - 气态：
                        微虫洞
                        火、光、电
                机器：
                    - 物流
                        - （6铁/12铁6煤/24铁1铅）传送带（运送物品）
                        - （24铁）传送梯（跨层传送带）
                        - （12铁）路由器（随机分物品）
                        - （12铁）分类器（按类别分物品）
                        每种传送带有三阶，快中慢，快是1刻，中是3刻，慢是5刻。
                    - 能量转化
                        - 势能电池（50%效率）：抬升机放6电转化成基态（可以手动消耗饭激发）；村民消耗1饭，将旁边（4邻居）的抬升机激发1个(冷却时间约5s)
                        - 热能电池（37.5%效率）：炉子将1煤转化成9火，蒸汽机将2火转化成1电；大棚将12光转化成1粮食，1粮食在炉子转化成1饭，1饭在炉子转化成1煤
                        - 太阳能电池：放大镜把2光转化成1火；白炽灯把3电转化成1光和2火，- LED灯把1电转化成1光
                        - 化学电池（83%效率）：电炉（消耗24电把1铁矿变24铁）+ 原电池（把24铁变1铁矿，产生20电）
                        - 可逆核过程电池（86%效率）：核反应堆把1铀变1铅，放144火，核子置入器把1铅变1铀，吸168火
                        - 反物质电池：光子对撞机吸144*4光和144*4火产生1铁和1反铁，两者在约束反应器中产生144*4光和136*4电
                        - 虫洞电池：时空界面消耗1728电和1728光产生微虫洞，微虫洞在反时空界面分解产生1728电和1680火

                    - 电动车充电（消耗6电，产生1圆钱，冷却6s）
                    - 钻头（挖矿）取决于位置，挖出铁矿、煤（1次挖24个）或1铀。消耗6电挖一格。铀是消耗6电和12铁
                    - 电炉（冶炼矿物）消耗24电把1铁矿变24铁，消耗24电把1铀矿变24铀
                    - 反物质增殖装置：24反铁和6铅，75%概率变25反铁，25%概率变24反铁
                    - 宇宙际强力浓差虫洞增殖装置：12微虫洞和3反铁，75%概率变13微虫洞，25%概率变12微虫洞
                固定设施：
                    - 商店（购买饭（2圆），煤（3圆）、铁（3圆））
                    - 插座、电表：把钱输入电表，插座就可以出电（冷却时间长，1s出1电，1圆钱出12电）
                    - 太阳（产生光，1s随机地点产生12个光）
                世界场景：自己的家里面、院子（可以自由放东西的地图，有2层）/邻居、商店（只是可以交互的场景）/手（一格空间可以存物品）
                剧情邻居人物：赵犰狳、钱蝙蝠、孙骆驼、李蜻蜓、...

                DLC或更新：
                - 钻头效应变化
                    - 在同一格挖的时间越长，挖的时间越慢，消耗能量越多，收益越好，但总体是更不值的。
                - 买地
                    - 买邻居家的院子、地。实现为多个Layer实例组（需要封装），院子间只能传输物品不能传输能量。（暂时不可能实现）
                - 蒸汽机温度
                    - 加入火升温，随时间降温，升温时转化效率高。
                - 压缩与解压
                    - 打包机把6个（相同）资源压成包裹，装载机把6个包裹装成集装箱，卸载机和解包机相反
                    - 不能处理气态物体
                - 升压/降压器
                    - 将6个普通电变成中压电，将6个中压电变成高压电
                - 机械齿轮组
                    - 将6个普通功变成中力功，将6个中力功变成大力功
                - 重量传送带
                    - 每个物品的重量是1，打包后重量变重，机器打包时将包好的物品输出到前方，可以根据重量决定运走或者不走
                - 显卡（消耗电，产生算力）
                - 手机（消耗电，产生网络数据包）
                - 加密货币钱包（消耗算力和网络数据包，产生金钱）
                - 银行（兑换钱的面额）
                - 研究科技，计算机消耗算力还有网络数据包（还有材料？），可以研究科技，刚开始不用计算机，是拿煤做书读书
                - 水、重水、聚变发电机
                - 资源
                    炎、焱
                    废料（辣鸡）
                    智子
                    功
                - 机械能/齿轮放大做的功

            写得很烂能乱玩就可以了，千万不要尝试抽象，写什么类
            */
        </script>
    </body>
</html>
