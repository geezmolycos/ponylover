<html>
    <head>
        <title>爱我的六色马可以做什么事</title>
        <meta charset="UTF-8">
	    <script
            src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
            crossorigin="anonymous"></script>
        <style>
            :root {
                --game-grid-size: 34px;
                --game-grid-border: 2px;
            }

            .layer-cont{
                position: relative;
            }
            .sublayer-cont{
                position: absolute;
                left: 0px;
                top: 0px;
            }
            .cell-wrapper{
                display: inline-block;
                width: var(--game-grid-size);
                height: var(--game-grid-size);
                box-sizing: border-box;
                padding-top: var(--game-grid-border);
                padding-left: var(--game-grid-border);
                image-rendering: pixelated;
            }
            .grid-cont{
                border-bottom: var(--game-grid-border) solid black;
                border-right: var(--game-grid-border) solid black;
                position: static;
                display: inline-block;
            }
            .grid-cont .cell-wrapper{
                border-top: var(--game-grid-border) solid black;
                border-left: var(--game-grid-border) solid black;
                padding-top: 0px;
                padding-left: 0px;
            }
        </style>
        <style>
            /* main ui frame styles */

            #game-center {
                text-align: center;
            }

            #game-cont {
                border: 2px dashed black;
                box-sizing: border-box;
                display: inline-block;
                text-align: initial;
            }

            #title-cont, #main-cont {
                display: block;
            }

            #title-cont {
                text-align: center;
                font-size: larger;
            }

            #yard-cont, #op-cont, #handinfo-cont{
                display: inline-block;
                vertical-align: top;
            }

            #yard-cont {
                width: calc(var(--game-grid-size) * 12 + var(--game-grid-border));
                height: calc(var(--game-grid-size) * 8 + var(--game-grid-border));
                overflow: hidden;
            }

            #op-cont {
                width: calc(var(--game-grid-size) * 8 + var(--game-grid-border));
            }

            #handinfo-cont {
                width: calc(var(--game-grid-size) * 6 + var(--game-grid-border));
            }

            #crafting-cont {
                margin-top: calc(var(--game-grid-size) - var(--game-grid-border));
            }

            .ground-layer-cont,  .underground-layer-cont {
                position: absolute;
            }

            .ground-layer-cont .grid-cont{
                border-bottom: var(--game-grid-border) solid gray;
                border-right: var(--game-grid-border) solid gray;
            }
            .ground-layer-cont .grid-cont .cell-wrapper{
                border-top: var(--game-grid-border) solid gray;
                border-left: var(--game-grid-border) solid gray;
            }

            .underground-layer-cont .grid-cont{
                border-bottom: var(--game-grid-border) solid rgb(156, 90, 24);
                border-right: var(--game-grid-border) solid rgb(156, 90, 24);
            }
            .underground-layer-cont .grid-cont .cell-wrapper{
                border-top: var(--game-grid-border) solid rgb(156, 90, 24);
                border-left: var(--game-grid-border) solid rgb(156, 90, 24);
            }

            #hand-cont, .game-button {
                display: inline-block;
                vertical-align: bottom;
            }

            .game-button{
                display: inline-block;
                border: 2px solid black;
            }

            #main-cont {
                position: relative;
            }

            #control-cont {
                position: absolute;
                bottom: 0;
            }

            #hand-cont {
                position: relative;
            }

            .hand-main-indicator {
                position: absolute;
                display: block;
                left: 0;
                top: 0;
                width: calc(var(--game-grid-size) + var(--game-grid-border));
                height: calc(var(--game-grid-size) + var(--game-grid-border));
                box-sizing: border-box;
                border: 3px solid orange;
            }

        </style>
    </head>
    <body>
        <div id="game-center">
            <div id="game-cont">
                <div id="title-cont">꒰ა ♡爱我的六色马可以做什么事♡ ໒꒱</div>
                <div id="main-cont">
                    <div id="yard-cont"></div>
                    <div id="handinfo-cont">
                        <div id="hand-cont"></div>
                        <div id="info-cont"></div>
                        <div id="control-cont"><button id="flip-yard" class="game-button">切换层</button></div>
                    </div>
                    <div id="op-cont">
                        <div id="state-selector-cont"></div>
                        <div id="crafting-cont"></div>
                    </div>
                </div>
                <div id="footer-cont"></div>
            </div>
        </div>
        <div>
            <button id="advance">advance</button>
            <button id="stop">stop</button>
            <span id="time">0</span>
        </div>
        <script>
            'use strict'

            const cardinal = [[0, -1], [-1, 0], [1, 0], [0, 1]];

            class EmptyEnt{
                can_place_item_on(inst){return true;}
                can_be_moved(inst){return true;}
                tick(inst){}
                draw(inst){}
                info(inst){return '什么也没有';}
                enum_states(){
                    return [];
                }
                init_other_states(state){}
            }

            function entity_dir_source(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x - dx, inst.y - dy];
                return [tx, ty];
            }
            function entity_dir_source_left(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x + dy, inst.y - dx];
                return [tx, ty];
            }
            function entity_dir_source_right(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x - dy, inst.y + dx];
                return [tx, ty];
            }

            function entity_dir_target(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x + dx, inst.y + dy];
                return [tx, ty];
            }

            function entity_output_item(inst, tx, ty, item_type, item_state){
                if (item_type == item_table.get('empty')){
                    return true;
                }
                if (item_type == null){
                    return false;
                }
                if (inst.layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                    || inst.layer.get_item_changed(tx, ty)
                    || !inst.layer.can_place_item_on(tx, ty)){
                    return false;
                }
                inst.layer.next_item_sublayer.swap(tx, ty, item_type, item_state);
                inst.layer.set_item_changed(tx, ty, true);
                return true;
            }

            class BeltEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    let [tx, ty] = entity_dir_target(inst);
                    if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                        inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                        inst.layer.set_item_changed(inst.x, inst.y, true);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){return '传送带'}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){}
            }

            class LadderEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    let tx = inst.x;
                    let ty = inst.y;
                    if (inst.layer.ladder_layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                        || inst.layer.ladder_layer.get_item_changed(tx, ty)
                        || !inst.layer.ladder_layer.can_place_item_on(tx, ty)){
                        return;
                    }
                    inst.layer.ladder_layer.next_item_sublayer.swap(tx, ty, old_item_inst.type, old_item_inst.state);
                    inst.layer.ladder_layer.set_item_changed(tx, ty, true);
                    inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                    inst.layer.set_item_changed(inst.x, inst.y, true);
                }
                draw(inst){
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [];
                }
                init_other_states(state){}
            }

            class RouterEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let tick_time = Math.floor(inst.layer.time / this.delay);
                    let leftup = tick_time % 6 === 0 || tick_time % 6 === 1 || tick_time % 6 === 4;
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);

                    let tx = inst.x;
                    let ty = inst.y;
                    if (inst.state.hv === 0){
                        tx += leftup ? -1 : 1;
                    } else {
                        ty += leftup ? -1 : 1;
                    }
                    if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                        inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                        inst.layer.set_item_changed(inst.x, inst.y, true);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '90deg'][inst.state.hv];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['hv', [0, 1]]
                    ];
                }
                init_other_states(state){}
            }

            class FilterEnt extends EmptyEnt{
                constructor(delay){
                    super();
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    
                    if (!inst.state.filter_inited){
                        inst.state.filter_inited = true;
                        inst.state.filter_item_type = inst.layer.item_sublayer.get_inst(inst.x, inst.y).type;
                        return;
                    }

                    let tick_time = Math.floor(inst.layer.time / this.delay);
                    let leftup = tick_time % 6 === 0 || tick_time % 6 === 1 || tick_time % 6 === 4;
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    if (old_item_inst.type === inst.state.filter_item_type){
                        let [tx, ty] = entity_dir_target(inst);
                        if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                            inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                            inst.layer.set_item_changed(inst.x, inst.y, true);
                        }
                    } else {
                        let tx = inst.x;
                        let ty = inst.y;
                        if (inst.state.hv === 0){
                            ty += leftup ? -1 : 1;
                        } else {
                            tx += leftup ? -1 : 1;
                        }
                        if (entity_output_item(inst, tx, ty, old_item_inst.type, old_item_inst.state)){
                            inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                            inst.layer.set_item_changed(inst.x, inst.y, true);
                        }
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0, 1, 2, 3]]
                    ];
                }
                init_other_states(state){
                    state.filter_inited = false;
                    state.filter_item_type = null;
                }
            }


            class MachineEnt extends EmptyEnt{
                constructor(ingredient_f, amounts, product_type, product_state, product_amount, cooldown_ticks){
                    super();
                    this.ingredient_f = ingredient_f;
                    this.amounts = amounts;
                    this.product_type = product_type;
                    this.product_state = product_state;
                    this.product_amount = product_amount;
                    this.cooldown_ticks = cooldown_ticks;
                    this.enable_lr_input = true;
                }
                can_place_item_on(inst){return false;}
                check_fulfill(inst){
                    if (inst.state.fulfilled){
                        return true;
                    }
                    let fulfilled = true;
                    $.each(this.amounts, (i, val) => {
                        if (inst.state.current_amounts[i] < val){
                            fulfilled = false;
                            return false;
                        }
                    });
                    return fulfilled;
                }
                set_fulfill(inst){
                    inst.state.fulfilled = true;
                    inst.state.remaining_output = this.product_amount;
                    inst.state.cooldown_ticks = this.cooldown_ticks;
                }
                tick(inst){
                    if (inst.state.remaining_output > 0){
                        if (inst.state.cooldown_ticks > 0){
                            inst.state.cooldown_ticks--;
                            return;
                        }
                        let [out_type, out_state] = [item_table.get('empty'), null];
                        if (this.on_output_item){
                            [out_type, out_state] = this.on_output_item(inst);
                        } else {
                            [out_type, out_state] = [this.product_type, this.product_state];
                        }
                        let [tx, ty] = entity_dir_target(inst);
                        if (entity_output_item(inst, tx, ty, out_type, out_state)){
                            inst.state.remaining_output--;
                            if (inst.state.remaining_output == 0){
                                this.init_other_states(inst.state);
                            }
                        }
                        return;
                    }
                    let [sx, sy] = entity_dir_source(inst);
                    if (inst.layer.time % 3 == 1){
                        [sx, sy] = entity_dir_source_left(inst);
                    } else if (inst.layer.time % 3 == 2){
                        [sx, sy] = entity_dir_source_right(inst);
                    }
                    if (inst.layer.get_item_changed(sx, sy)
                        || inst.layer.item_sublayer.get_inst(sx, sy).type === item_table.get('empty')){
                        return;
                    }
                    let ingredient_i = -1;
                    let input = inst.layer.item_sublayer.get_inst(sx, sy);
                    let [type, state] = [input.type, input.state];
                    if (this.on_input_item){
                        ingredient_i = this.on_input_item(inst, type, state);
                    } else {
                        ingredient_i = this.ingredient_f(type, state);
                    }
                    if (ingredient_i === -1){
                        return;
                    }
                    if (inst.state.current_amounts[ingredient_i] >= this.amounts[ingredient_i]){
                        return;
                    }
                    inst.state.current_amounts[ingredient_i]++;
                    inst.layer.next_item_sublayer.swap(sx, sy, item_table.get('empty'), null);
                    inst.layer.set_item_changed(sx, sy, true);
                    if (this.check_fulfill(inst)){
                        this.set_fulfill(inst);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('width', '100%').css('height', '100%')
                        .css('transform', `rotate(${rotation})`)
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`);
                }
                info(inst){
                    let $e = $('<span>');
                    if (this.basicinfo){
                        $e.append(this.basicinfo(inst));
                    }
                    $e.append($('<br><br>'));
                    let ing_names = [];
                    if (this.ing_names){
                        ing_names = this.ing_names(inst);
                    }
                    $e.append('原料: ')
                    $e.append($('<br>'));
                    for (let i in ing_names){
                        let name = ing_names[i];
                        let current_amount = inst.state.current_amounts[i];
                        let required_amount = inst.type.amounts[i];
                        if (current_amount == required_amount){
                            $e.append($('<span>').text(`${name}: ${current_amount}/${required_amount}`).css('color', 'green'));
                        } else {
                            $e.append($('<span>').text(`${name}: ${current_amount}/${required_amount}`));
                        }
                        $e.append($('<br>'));
                    }
                    $e.append($('<br>'));
                    if (inst.state.cooldown_ticks !== 0){
                        $e.append($('<span>').text('制作中...').css('color', 'red'));
                        $e.append($('<br>'));
                    }
                    if (inst.state.remaining_output !== 0 && inst.state.cooldown_ticks === 0){
                        $e.append($('<span>').text('输出物品中...').css('color', 'olive'));        
                        $e.append($('<br>'));
                    }
                    return $e;
                }
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){
                    state.fulfilled = false;
                    state.remaining_output = 0;
                    state.current_amounts = new Array(this.amounts.length).fill(0);
                    if (!state.cooldown_ticks){
                        state.cooldown_ticks = 0;
                    }
                }
            }

            class EmptyItem{
                draw(inst){}
                info(inst){}
                as_crafting_ingredient(inst){
                    return [inst.type, 1];
                }
            }

            class IconItem extends EmptyItem{
                constructor(icon, pos_x, pos_y){
                    super();
                    this.icon = icon;
                    this.pos_x = pos_x;
                    this.pos_y = pos_y;
                }
                draw(inst){
                    let opacity = 1;
                    if (this.life && inst.state && inst.state.life){
                        opacity = inst.state.life / this.life(inst) * 0.5 + 0.5;
                    }
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '512px 512px')
                        .css('background-position', `-${this.pos_x * 32}px -${this.pos_y * 32}px`)
                        .css('opacity', opacity)
                        .css('width', '32px').css('height', '32px');
                }
                info(inst){}
            }

            let item_table = new Map([
                ['empty', new EmptyItem()],
                ['crop', new IconItem("./texture.png", 0, 0)],
                ['food', new IconItem("./texture.png", 1, 0)],
                ['coal', new IconItem("./texture.png", 2, 0)],
                ['iron_ore', new IconItem("./texture.png", 3, 0)],
                ['uran_ore', new IconItem("./texture.png", 4, 0)],
                ['iron_ingot', new IconItem("./texture.png", 3, 1)],
                ['uran_ingot', new IconItem("./texture.png", 4, 1)],
                ['anti_iron_ingot', new IconItem("./texture.png", 3, 2)],
                ['lead_ingot', new IconItem("./texture.png", 4, 2)],
                ['fire', (()=>{let e = new IconItem("./texture.png", 0, 4); e.life = (inst)=>(120); e.kill_prob = (inst)=>(1-Math.pow(0.5, 1/20)); return e})()],
                ['light', (()=>{let e = new IconItem("./texture.png", 1, 4); e.life = (inst)=>(120); e.kill_prob = (inst)=>(1-Math.pow(0.5, 1/20)); return e})()],
                ['elec', (()=>{let e = new IconItem("./texture.png", 2, 4); e.life = (inst)=>(120); e.kill_prob = (inst)=>(1-Math.pow(0.5, 1/20)); return e})()],
                ['wormhole', new IconItem("./texture.png", 4, 4)],
                ['coin', new IconItem("./texture.png", 0, 5)],
            ]);

            let entity_table = new Map([
                ['empty', new EmptyEnt()],
                ['belt', (()=>{
                    let e = new BeltEnt(5); e.icon='./texture.png'; e.pos_x=0; e.pos_y=6;
                    e.info = (inst)=>('普通的传送带，1秒可以将物品运输4格。');
                    return e
                })()],
                ['fast_belt', (()=>{
                    let e = new BeltEnt(3); e.icon='./texture.png'; e.pos_x=1; e.pos_y=6;
                    e.info = (inst)=>('更好的传送带，1秒可以将物品运输7格。');
                    return e
                })()],
                ['faster_belt', (()=>{
                    let e = new BeltEnt(1); e.icon='./texture.png'; e.pos_x=2; e.pos_y=6;
                    e.info = (inst)=>('使用金属铅加强过的传送带，可以承受更高的旋转速度，1秒可以将物品运输20格。');
                    return e
                })()],
                ['ladder', (()=>{
                    let e = new LadderEnt(5); e.icon='./texture.png'; e.pos_x=0; e.pos_y=7;
                    e.info = (inst)=>('传送梯，将物品在地表和地下间运输。');
                    return e
                })()],
                ['router', (()=>{
                    let e = new RouterEnt(1); e.icon='./texture.png'; e.pos_x=1; e.pos_y=7;
                    e.info = (inst)=>('分流器，将其上的物品分流到两侧。');
                    return e
                })()],
                ['filter', (()=>{
                    let e = new FilterEnt(5); e.icon='./texture.png'; e.pos_x=2; e.pos_y=7;
                    e.info = (inst)=>(
                        $('<span>')
                            .append('过滤器，记住其上的第一个物品，使此类物品通过，其他物品分流至两侧。')
                            .append($('<br><br>'))
                            .append('更改方向后会自动清除物品')
                            .append($('<br><br>'))
                            .append(inst.state.filter_inited ? '当前物品: ' : '当前没有物品')
                            .append(inst.state.filter_inited ? inst.state.filter_item_type.draw(null) : null));
                    return e
                })()],
                ['gravity_gen', (()=>{
                    let e = new MachineEnt((type, state)=>(-1), [1], item_table.get('elec'), null, 6, 50);
                    e.icon='./texture.png'; e.pos_x=0; e.pos_y=9;
                    e.info = (inst)=>(
                        $('<span>')
                            .append('过滤器，记住其上的第一个物品，使此类物品通过，其他物品分流至两侧。')
                            .append($('<br><br>'))
                            .append('更改方向后会自动清除物品')
                            .append($('<br><br>'))
                            .append(inst.state.filter_inited ? '当前物品: ' : '当前没有物品')
                            .append(inst.state.filter_inited ? inst.state.filter_item_type.draw(null) : null));
                    return e
                })()],
                ['villager', (()=>{
                    let e = new MachineEnt(
                        (type, state)=>(type == item_table.get('food') ? 0 : -1),
                        [1], item_table.get('empty'), null, 1, 100
                    );
                    e.on_output_item = (inst) => {
                        let gravity_gen_txy = [];
                        for (let dir = 0; dir < 4; dir++){
                            let [dx, dy] = cardinal[dir];
                            let [tx, ty] = [inst.x + dx, inst.y + dy];
                            if (inst.layer.get_entity_changed(tx, ty)){
                                continue;
                            }
                            if (inst.layer.entity_sublayer.get_inst(tx, ty).type == entity_table.get('gravity_gen')){
                                gravity_gen_txy.push([tx, ty]);
                            }
                        }
                        let target_gravity_gen_i = Math.floor(Math.random() * gravity_gen_txy.length);
                        let [tx, ty] = gravity_gen_txy[target_gravity_gen_i];
                        let gen_inst = inst.layer.next_entity_sublayer.get_inst(tx, ty);
                        if (gen_inst.type.check_fulfill(gen_inst)){
                            return [null, null];
                        }
                        gen_inst.type.set_fulfill(gen_inst);
                        return [item_table.get('empty'), null];
                    }
                    e.basicinfo = (inst)=>("为你工作的村民，吃食物后可以激活旁边的抬升机。");
                    e.ing_names = (inst)=>(["食物"]);
                    e.icon='./texture.png'; e.pos_x=2; e.pos_y=9; return e
                })()],
                ['stove', (()=>{
                    let e = new MachineEnt(
                        null,
                        [1], item_table.get('empty'), null, 1, 100
                    );
                    e.on_input_item = (inst, type, state)=>{
                        if (type == item_table.get('coal')){
                            inst.state.recipe = 'coal';
                        } else if (type == item_table.get('crop')){
                            inst.state.recipe = 'crop';
                        } else if (type == item_table.get('food')){
                            inst.state.recipe = 'food';
                        }
                        inst.state.coal_output_amount_init = false;
                        return (type == item_table.get('coal') || type == item_table.get('crop') || type == item_table.get('food')) ? 0 : -1;
                    }
                    e.on_output_item = (inst) => {
                        if (inst.state.recipe == 'coal'){
                            if (!inst.state.coal_output_amount_init){
                                inst.state.coal_output_amount_init = true;
                                inst.state.remaining_output = 9;
                            }
                            return [item_table.get('fire'), null];
                        } else if (inst.state.recipe == 'crop'){
                            return [item_table.get('food'), null];
                        } else if (inst.state.recipe == 'food'){
                            return [item_table.get('coal'), null];
                        } else {
                            return [item_table.get('empty'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("火炉，可以将煤燃烧成火，将粮食做成食物，将食物烧成煤。");
                    e.ing_names = (inst)=>(["可燃烧物"]);
                    e.icon='./texture.png'; e.pos_x=3; e.pos_y=9; return e
                })()],
                ['steam_gen', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('fire') ? 0 : -1), [2], item_table.get('elec'), null, 1, 10);
                    e.basicinfo = (inst)=>("蒸汽发电机，可以使用火来发电。");
                    e.ing_names = (inst)=>(["火"]);
                    e.icon='./texture.png'; e.pos_x=4; e.pos_y=9; return e
                })()],
                ['farm', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('light') ? 0 : -1), [12], item_table.get('food'), null, 1, 100);
                    e.basicinfo = (inst)=>("大棚农场，吸收外界的光促进植物生长，可以产出粮食。");
                    e.ing_names = (inst)=>(["光"]);
                    e.icon='./texture.png'; e.pos_x=5; e.pos_y=9; return e
                })()],
                ['magnifier', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('light') ? 0 : -1), [2], item_table.get('fire'), null, 1, 10);
                    e.basicinfo = (inst)=>("放大镜，上面的凸透镜可以将光聚焦起来，产生火。");
                    e.ing_names = (inst)=>(["光"]);
                    e.icon='./texture.png'; e.pos_x=6; e.pos_y=9; return e
                })()],
                ['lightbulb', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : -1), [3], item_table.get('empty'), null, 3, 10);
                    e.on_output_item = (inst) => {
                        let is_fire = Math.random() * 3 < 2;
                        if (is_fire){
                            return [item_table.get('fire'), null];
                        } else {
                            return [item_table.get('light'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("白炽灯，消耗电，大多数电都用作加热灯丝了，只有少数电可以用来发光。");
                    e.ing_names = (inst)=>(["电"]);
                    e.icon='./texture.png'; e.pos_x=7; e.pos_y=9; return e
                })()],
                ['led', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : -1), [1], item_table.get('light'), null, 1, 3);
                    e.basicinfo = (inst)=>("利用半导体科技制作的发光二极管，可以将输入的所有电能转化成光能。");
                    e.ing_names = (inst)=>(["电"]);
                    e.icon='./texture.png'; e.pos_x=8; e.pos_y=9; return e
                })()],
                ['elec_furnace', (()=>{
                    let e = new MachineEnt(null, [1, 24], item_table.get('iron_ingot'), null, 24, 100);
                    e.on_input_item = (inst, type, state) => {
                        if (inst.state.current_amounts[0] === 0){
                            return type === item_table.get('iron_ore') ? 0 : -1;
                        } else {
                            return type === item_table.get('elec') ? 1 : -1;
                        }
                    }
                    e.basicinfo = (inst)=>("电炉，利用电将铁矿冶炼成铁锭。");
                    e.ing_names = (inst)=>(['铁矿', "电"]);
                    e.icon='./texture.png'; e.pos_x=0; e.pos_y=10; return e
                })()],
                ['uran_furnace', (()=>{
                    let e = new MachineEnt(null, [1, 24], item_table.get('uran_ingot'), null, 3, 100);
                    e.on_input_item = (inst, type, state) => {
                        if (inst.state.current_amounts[0] === 0){
                            return type === item_table.get('uran_ore') ? 0 : -1;
                        } else {
                            return type === item_table.get('elec') ? 1 : -1;
                        }
                    }
                    e.basicinfo = (inst)=>("铀离心机，将铀矿处理为可供给反应堆的铀锭。");
                    e.ing_names = (inst)=>(["铀矿", '电']);
                    e.icon='./texture.png'; e.pos_x=0; e.pos_y=10; return e
                })()],
                ['battery', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('iron_ingot') ? 0 : -1), [24], item_table.get('empty'), null, 21, 100);
                    e.on_output_item = (inst) => {
                        if (inst.state.remaining_output == 1){
                            return [item_table.get('iron_ore'), null];
                        } else {
                            return [item_table.get('elec'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("化学原电池，可以从金属铁到铁矿的反应中获取电能。");
                    e.ing_names = (inst)=>(['铁锭']);
                    e.icon='./texture.png'; e.pos_x=1; e.pos_y=10; return e
                })()],
                ['nuclear_reactor', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('uran_ingot') ? 0 : -1), [1], item_table.get('empty'), null, 145, 100);
                    e.on_output_item = (inst) => {
                        if (inst.state.remaining_output == 1){
                            return [item_table.get('lead_ingot'), null];
                        } else {
                            return [item_table.get('fire'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("核反应堆，从铀元素的链式裂变反应中获取能量。");
                    e.ing_names = (inst)=>(['铀锭']);
                    e.icon='./texture.png'; e.pos_x=2; e.pos_y=10; return e
                })()],
                ['nuclear_antireactor', (()=>{
                    let e = new MachineEnt(null, [1, 168], item_table.get('uran_ingot'), null, 1, 100);
                    e.on_input_item = (inst, type, state) => {
                        if (inst.state.current_amounts[0] === 0){
                            return type === item_table.get('lead_ingot') ? 0 : -1;
                        } else {
                            return type === item_table.get('fire') ? 1 : -1;
                        }
                    }
                    e.basicinfo = (inst)=>("核子置入器，使用能量将质子和中子塞入铅原子核中，产生铀元素。");
                    e.ing_names = (inst)=>(['铅锭', '火']);
                    e.icon='./texture.png'; e.pos_x=3; e.pos_y=10; return e
                })()],
                ['anitimatter_gen', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('light') ? 0 : (type == item_table.get('fire') ? 1 : -1)), [144*4, 144*4], item_table.get('empty'), null, 2, 100);
                    e.on_output_item = (inst) => {
                        if (inst.state.remaining_output == 1){
                            return [item_table.get('anti_iron_ingot'), null];
                        } else {
                            return [item_table.get('iron_ingot'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("光子对撞机，使用极高能量将光子转化为正反物质，以铁和反铁的形式储存在引力井中。");
                    e.ing_names = (inst)=>(['光', '火']);
                    e.icon='./texture.png'; e.pos_x=4; e.pos_y=10; return e
                })()],
                ['anitimatter_reactor', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('iron_ingot') ? 0 : (type == item_table.get('anti_iron_ingot') ? 1 : -1)), [1, 1], item_table.get('empty'), null, 144*4+136*4, 100);
                    e.on_output_item = (inst) => {
                        if ((inst.state.remaining_output - 1) % (18+17) < 18){
                            return [item_table.get('light'), null];
                        } else {
                            return [item_table.get('elec'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("约束反应器，操纵引力壁垒，使引力井中的正反物质缓慢湮灭，放出光能和电能。");
                    e.ing_names = (inst)=>(['光', '火']);
                    e.icon='./texture.png'; e.pos_x=5; e.pos_y=10; return e
                })()],
                ['wormhole_gen', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : (type == item_table.get('light') ? 1 : -1)), [1728, 1728], item_table.get('wormhole'), null, 1, 100);
                    e.basicinfo = (inst)=>("时空界面，通过操作和折叠极端能量条件下的空间，制造稳定的微虫洞，其中包含巨大能量。");
                    e.ing_names = (inst)=>(['电', '光']);
                    e.icon='./texture.png'; e.pos_x=6; e.pos_y=10; return e
                })()],
                ['wormhole_reactor', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('wormhole') ? 0 : -1), [1], item_table.get('empty'), null, 1728+1680, 100);
                    e.on_output_item = (inst) => {
                        if ((inst.state.remaining_output - 1) % (36+35) < 36){
                            return [item_table.get('elec'), null];
                        } else {
                            return [item_table.get('fire'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("反时空界面，解构微虫洞内部的空间结构，利用时空的展开获取巨大能量，放出电能和热能。");
                    e.ing_names = (inst)=>(['电', '光']);
                    e.icon='./texture.png'; e.pos_x=7; e.pos_y=10; return e
                })()],
                ['coin_maker', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : -1), [6], item_table.get('coin'), null, 1, 120);
                    e.basicinfo = (inst)=>("电动车充电站，通过给邻居家的电动车充电赚钱。");
                    e.ing_names = (inst)=>(['电']);
                    e.icon='./texture.png'; e.pos_x=0; e.pos_y=11; return e
                })()],
                ['drill', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : -1), [6], item_table.get('empty'), null, 24, 120);
                    e.mine = (inst) => {
                        let hash = (53 + inst.y * 101) * 53 + inst.x * 101;
                        let m = hash % 32;
                        if (m < 10){
                            return 'coal';
                        } else {
                            return 'iron';
                        }
                    }
                    e.on_output_item = (inst) => {
                        let recipe = e.mine(inst);
                        if (recipe == 'coal'){
                            return [item_table.get('coal'), null];
                        } else if (recipe == 'iron'){
                            if (inst.state.remaining_output < 24){
                                return [item_table.get('empty'), null];
                            } else {
                                return [item_table.get('iron_ore'), null];
                            }
                        }
                    }
                    e.basicinfo = (inst)=>("挖矿钻头，只能在地下工作，依照所处的位置不同，可能挖出铁矿或煤。");
                    e.ing_names = (inst)=>(['电']);
                    e.icon='./texture.png'; e.pos_x=1; e.pos_y=11; return e
                })()],
                ['uran_drill', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('elec') ? 0 : (type == item_table.get('iron_ingot') ? 1 : -1)), [6, 12], item_table.get('uran_ore'), null, 24, 480);
                    e.basicinfo = (inst)=>("深层挖矿钻头，只能在地下工作，需要消耗铁锭，能够挖出铀矿。");
                    e.ing_names = (inst)=>(['电', '铁锭']);
                    e.icon='./texture.png'; e.pos_x=1; e.pos_y=11; return e
                })()],
                ['antimatter_enricher', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('anti_iron_ingot') ? 0 : (type == item_table.get('lead_ingot') ? 1 : -1)), [24, 6], item_table.get('empty'), null, 25, 100);
                    e.on_output_item = (inst) => {
                        if (inst.state.remaining_output == 1){
                            if (Math.random() < 0.75){
                                return [item_table.get('anti_iron_ingot'), null];
                            } else {
                                return [item_table.get('empty'), null];
                            }
                        } else {
                            return [item_table.get('anti_iron_ingot'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("反物质增殖装置，使用物质和反物质的交互作用，进行反物质的远距交换。消耗重元素金属铅，将反铁变多。因为宇宙环境的不稳定性，增殖过程有可能会失败。");
                    e.ing_names = (inst)=>(['反铁锭', '铅锭']);
                    e.icon='./texture.png'; e.pos_x=2; e.pos_y=11; return e
                })()],
                ['wormhole_enricher', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('wormhole') ? 0 : (type == item_table.get('anti_iron_ingot') ? 1 : -1)), [12, 3], item_table.get('empty'), null, 13, 100);
                    e.on_output_item = (inst) => {
                        if (inst.state.remaining_output == 1){
                            if (Math.random() < 0.75){
                                return [item_table.get('wormhole'), null];
                            } else {
                                return [item_table.get('empty'), null];
                            }
                        } else {
                            return [item_table.get('wormhole'), null];
                        }
                    }
                    e.basicinfo = (inst)=>("宇宙际强力浓差虫洞增殖装置，使用多元宇宙的物理特性差别，展开已有微虫洞中蕴含的连续时空，使用反物质交换出平行宇宙中存在的微虫洞。因为平行宇宙的时空特性不稳定，增殖过程有可能会失败。");
                    e.ing_names = (inst)=>(['微虫洞', '反铁锭']);
                    e.icon='./texture.png'; e.pos_x=3; e.pos_y=11; return e
                })()],
                ['store_food', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('coin') ? 0 : -1), [2], item_table.get('food'), null, 1, 100);
                    e.basicinfo = (inst)=>("商店，在这里可以买食物。");
                    e.ing_names = (inst)=>(['钱币']);
                    e.icon='./texture.png'; e.pos_x=4; e.pos_y=11; return e
                })()],
                ['store_coal', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('coin') ? 0 : -1), [3], item_table.get('coal'), null, 1, 100);
                    e.basicinfo = (inst)=>("商店，在这里可以买煤。");
                    e.ing_names = (inst)=>(['钱币']);
                    e.icon='./texture.png'; e.pos_x=4; e.pos_y=11; return e
                })()],
                ['store_iron', (()=>{
                    let e = new MachineEnt((type, state)=>(type == item_table.get('coin') ? 0 : -1), [3], item_table.get('iron'), null, 1, 100);
                    e.basicinfo = (inst)=>("商店，在这里可以买铁锭。");
                    e.ing_names = (inst)=>(['钱币']);
                    e.icon='./texture.png'; e.pos_x=4; e.pos_y=11; return e
                })()],
            ]);

            class YardSubLayer{
                constructor(layer, init_val){
                    this.layer = layer;
                    this.empty(init_val);
                }

                swap(x, y, new_type, new_state){
                    const i = this.layer.xy2i(x, y);
                    const old_type = this.type[i];
                    const old_state = this.state.get(i) || null;
                    this.state.delete(i);
                    this.type[i] = new_type;
                    if (new_state !== null){
                        this.state.set(i, new_state);
                    }
                    return [old_type, old_state];
                }

                make_cont(){
                    let $sublayer_cont = $('<div>').addClass('sublayer-cont');
                    for (let y=0; y<this.layer.height; y++){
                        for (let x=0; x<this.layer.width; x++){
                            const wrapper = $('<div>').addClass('cell-wrapper').attr('data-x', x).attr('data-y', y);
                            $sublayer_cont.append(wrapper);
                        }
                        $sublayer_cont.append($('<br>'));
                    }
                    return $sublayer_cont;
                }

                get_inst(x, y){
                    let state = this.state.get(this.layer.xy2i(x, y)) || null;
                    let type = this.type[this.layer.xy2i(x, y)];
                    return {
                        layer: this.layer,
                        x: x,
                        y: y,
                        type: type,
                        state: state,
                    }
                }

                draw_all($sublayer_cont){
                    let that = this;
                    $sublayer_cont.children('.cell-wrapper').each((_, wrapper)=>{
                        let $wrapper = $(wrapper);
                        const x = $wrapper.data('x');
                        const y = $wrapper.data('y');
                        $wrapper.empty();
                        let inst = that.get_inst(x, y);
                        let c = inst.type.draw(inst);
                        $wrapper.append(c);
                    });
                }


                empty(init_val){
                    this.type = new Array(this.layer.width * this.layer.height).fill(init_val);
                    this.state = new Map();
                }
            }

            class YardLayer{
                constructor(width, height){
                    this.width = width;
                    this.height = height;
                    this.entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.next_entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.entity_changed = new Array(this.width * this.height).fill(false);
                    this.item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.next_item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.item_changed = new Array(this.width * this.height).fill(false);
                    this.time = 0;
                }

                get_entity_changed(x, y){
                    return this.entity_changed[this.xy2i(x, y)];
                }
                
                set_entity_changed(x, y, val){
                    this.entity_changed[this.xy2i(x, y)] = val;
                }

                get_item_changed(x, y){
                    return this.item_changed[this.xy2i(x, y)];
                }

                set_item_changed(x, y, val){
                    this.item_changed[this.xy2i(x, y)] = val;
                }

                can_place_item_on(x, y){
                    if (!this.is_in_border(x, y)){
                        return false;
                    }
                    let inst = this.entity_sublayer.get_inst(x, y);
                    let ninst = this.next_entity_sublayer.get_inst(x, y);
                    return inst.type.can_place_item_on(inst) && ninst.type.can_place_item_on(ninst);
                }

                xy2i(x, y){
                    return this.width * y + x;
                }

                i2xy(i){
                    return [i % this.width, Math.floor(i / this.width)];
                }

                is_in_border(x, y){
                    return 0 <= x && x < this.width && 0 <= y && y < this.height;
                }

                do_tick_reversed(){
                    return this.time % 4 < 2;
                }

                tick_all(){
                    // process item life
                    for (let y=0; y<this.height; y++){
                        for (let x=0; x<this.width; x++){
                            let item_inst = this.item_sublayer.get_inst(x, y);
                            if (item_inst.type.life !== undefined){
                                if (item_inst.state === null){
                                    this.next_item_sublayer.swap(x, y, item_inst.type, {life: item_inst.type.life(item_inst)});
                                    this.set_item_changed(x, y, true);
                                } else if (item_inst.state.life === undefined){
                                    item_inst.state.life = item_inst.type.life(item_inst);
                                } else if (item_inst.state.life > 0){
                                    item_inst.state.life--;
                                } else if (item_inst.state.life == 0){
                                    if (Math.random() < item_inst.type.kill_prob(item_inst)){
                                        this.next_item_sublayer.swap(x, y, item_table.get('empty'), null);
                                        this.set_item_changed(x, y, true);
                                    }
                                }
                                
                            }
                        }
                    }
                    if (this.do_tick_reversed()){
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(this.width - x - 1, this.height - y - 1);
                            }
                        }
                    } else {
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(x, y);
                            }
                        }
                    }
                    this.item_sublayer.type = [...this.next_item_sublayer.type];
                    this.item_sublayer.state = new Map(this.next_item_sublayer.state);
                    this.item_changed.fill(false);
                    this.entity_sublayer.type = [...this.next_entity_sublayer.type];
                    this.entity_sublayer.state = new Map(this.next_entity_sublayer.state);
                    this.entity_changed.fill(false);
                    this.time++;
                }

                tick_at(x, y){
                    let inst = this.entity_sublayer.get_inst(x, y);
                    inst.type.tick(inst);
                }

                on_mouse_place_entity(inst){
                    return {
                        able: true,
                        type: entity_table.get('empty'),
                        state: null
                    };
                }

                layer_specific_info(inst){
                    return null;
                }

                make_cont(callback_output_info, callback_clear_info){
                    let $cont = $('<div>').addClass('layer-cont');
                    let $grid_cont = this.entity_sublayer.make_cont().addClass('grid-cont');
                    let $entity_cont = this.entity_sublayer.make_cont().addClass('entity-sublayer-cont');
                    let $item_cont = this.item_sublayer.make_cont().addClass('item-sublayer-cont');
                    let $mouseclick_cont = this.entity_sublayer.make_cont().addClass('mouseclick-cont');
                    $mouseclick_cont.children('.cell-wrapper').on('click', (e)=>{
                        let x = $(e.target).data('x');
                        let y = $(e.target).data('y');
                        let inst = this.next_entity_sublayer.get_inst(x, y);
                        let res = this.on_mouse_place_entity(inst);
                        if (!res.able){
                            return;
                        }
                        this.next_entity_sublayer.swap(x, y, res.type, res.state);
                    });
                    let task_id = null;
                    $mouseclick_cont.children('.cell-wrapper').on('mouseenter', (e)=>{
                        let x = $(e.target).data('x');
                        let y = $(e.target).data('y');
                        $mouseclick_cont.children(`[data-x=${x}][data-y=${y}]`).css('background-color', 'rgba(255, 255, 0, 0.2)');
                        $item_cont.children(`[data-x=${x}][data-y=${y}]`).css('opacity', '0.2');
                        let f = ()=>{
                            let inst = this.next_entity_sublayer.get_inst(x, y);
                            if (callback_output_info){
                                let $d = $('<div>');
                                $d.append(inst.type.info(inst));
                                $d.append(this.layer_specific_info(inst));
                                callback_output_info($d);
                            }
                        }
                        f();
                        task_id = setInterval(f, 200);
                    });
                    $mouseclick_cont.children('.cell-wrapper').on('mouseleave', (e)=>{
                        let x = $(e.target).data('x');
                        let y = $(e.target).data('y');
                        $mouseclick_cont.children(`[data-x=${x}][data-y=${y}]`).css('background-color', '');
                        $item_cont.children(`[data-x=${x}][data-y=${y}]`).css('opacity', '');
                        clearInterval(task_id);
                        if (callback_clear_info){
                            callback_clear_info();
                        }
                    });
                    $cont.append($grid_cont).append($entity_cont).append($item_cont).append($mouseclick_cont);
                    return $cont;
                }

                draw_all($layer_cont){
                    let $entity_cont = $layer_cont.children('.entity-sublayer-cont');
                    let $item_cont = $layer_cont.children('.item-sublayer-cont');
                    this.next_entity_sublayer.draw_all($entity_cont);
                    this.next_item_sublayer.draw_all($item_cont);
                }
            }

            let global_debug = true;
            let debug_tooltip = global_debug;

            function clear_info(){
                $('.item-info').empty();
            }

            function clear_and_show_hand(){
                let entity_inst = hand_layer.get_entity_inst();
                let info = entity_inst.type.info(entity_inst);
                $('.item-info').empty();
                $('.item-info').append(info);
                if (debug_tooltip){
                    $('.item-debug-state').empty();
                    $('.item-debug-state').append(JSON.stringify(entity_inst.state));
                }
            }

            function show_info(info){
                clear_info();
                $('.item-info').append(info);
            }
            
        
            let ground_layer = new YardLayer(12, 8);
            let underground_layer = new YardLayer(12, 8);
            ground_layer.ladder_layer = underground_layer;
            underground_layer.ladder_layer = ground_layer;

            ground_layer.on_mouse_place_entity = underground_layer.on_mouse_place_entity = (inst)=>{
                if (!inst.type.can_be_moved(inst)){
                    return {
                        able: false
                    };
                }
                let [swap_out_type, swap_out_state] = inst.layer.hand_layer.next_entity_sublayer.swap(0, 0, inst.type, inst.state);
                hand_autosupply();
                redraw_hand_and_selector();
                return {
                    able: true,
                    type: swap_out_type,
                    state: swap_out_state
                };
            }
            
            let $layer_cont = ground_layer.make_cont(show_info, clear_and_show_hand).addClass('ground-layer-cont');
            let $underground_layer_cont = underground_layer.make_cont(show_info, clear_and_show_hand).addClass('underground-layer-cont');
            $('#yard-cont').append($layer_cont);
            $('#yard-cont').append($underground_layer_cont);

            let hand_layer = new YardLayer(3, 2);
            hand_layer.get_entity_inst = function(){
                return this.next_entity_sublayer.get_inst(0, 0);
            }
            hand_layer.get_item_inst = function(){
                return this.next_item_sublayer.get_inst(0, 0);
            }
            let $hand_layer_cont = hand_layer.make_cont(show_info, clear_and_show_hand);
            $('#hand-cont').append($hand_layer_cont);
            ground_layer.hand_layer = hand_layer;
            underground_layer.hand_layer = hand_layer;

            hand_layer.on_mouse_place_entity = (inst)=>{
                let [x, y] = [inst.x, inst.y];
                let i = inst.layer.xy2i(inst.x, inst.y);
                if (i === 0){
                    return {
                        able: false
                    };
                }
                let [orig_hand_type, orig_hand_state] = hand_layer.next_entity_sublayer.swap(0, 0, entity_table.get('empty'), null);
                let [swap_out_type, swap_out_state] = hand_layer.next_entity_sublayer.swap(x, y, orig_hand_type, orig_hand_state);
                hand_layer.next_entity_sublayer.swap(0, 0, swap_out_type, swap_out_state);
                redraw_hand_and_selector();
                return {
                    able: false
                };
            }

            function hand_has_space(){
                let i=0;
                let [x, y] = hand_layer.i2xy(i);
                while (hand_layer.entity_sublayer.get_inst(x, y).type !== entity_table.get('empty')){
                    i++;
                    [x, y] = hand_layer.i2xy(i);
                    if (i>= hand_layer.width * hand_layer.height){
                        return false;
                    }
                }
                return true;
            }

            function hand_autosupply(){
                let i=0;
                let [x, y] = hand_layer.i2xy(i);
                while (hand_layer.next_entity_sublayer.get_inst(x, y).type === entity_table.get('empty')){
                    i++;
                    [x, y] = hand_layer.i2xy(i);
                    if (i>= hand_layer.width * hand_layer.height){
                        return false;
                    }
                }
                if (i === 0){
                    return true;
                }
                let [orig_hand_type, orig_hand_state] = hand_layer.next_entity_sublayer.swap(0, 0, entity_table.get('empty'), null);
                let [swap_out_type, swap_out_state] = hand_layer.next_entity_sublayer.swap(x, y, orig_hand_type, orig_hand_state);
                hand_layer.next_entity_sublayer.swap(0, 0, swap_out_type, swap_out_state);
                return true;
            }

            function hand_autoinsert(type, state){
                let i=0;
                let [x, y] = hand_layer.i2xy(i);
                while (hand_layer.next_entity_sublayer.get_inst(x, y).type !== entity_table.get('empty')){
                    i++;
                    [x, y] = hand_layer.i2xy(i);
                    if (i>= hand_layer.width * hand_layer.height){
                        return false;
                    }
                }
                hand_layer.next_entity_sublayer.swap(x, y, type, state);
                return true;
            }

            $('#hand-cont').append($('<div>').addClass('hand-main-indicator'))

            let $state_selector_cont = $('<div>').addClass('state-selector-cont');
            $('#info-cont').append($('<div>').addClass('item-info'));
            $('#info-cont').append($('<div>').addClass('item-debug-state'));
            $state_selector_cont.append($('<div>').addClass('state-enum'));
            let selector_layer = new YardLayer(8, 2);
            let $selector_layer_cont = selector_layer.make_cont(show_info, clear_and_show_hand);
            $state_selector_cont.children('.state-enum').append($selector_layer_cont);
            $('#state-selector-cont').append($state_selector_cont);

            let selected_states = new Map();

            selector_layer.on_mouse_place_entity = (inst)=>{
                if (inst.type === entity_table.get('empty')){
                    return {
                        able: false
                    };
                }
                for (let [state_name, state_values] of inst.type.enum_states()){
                    selected_states.set(state_name, inst.state[state_name]);
                }
                let [swap_out_type, swap_out_state] = hand_layer.next_entity_sublayer.swap(0, 0, inst.type, inst.state);
                hand_autosupply();
                redraw_hand_and_selector();
                return {
                    able: false
                };
            }

            function redraw_hand_and_selector(){
                let entity_inst = hand_layer.get_entity_inst();
                hand_layer.draw_all($hand_layer_cont);
                clear_and_show_hand();
                let enum_states = entity_inst.type.enum_states();
                let x=0, y=0;
                selector_layer.next_entity_sublayer.empty(entity_table.get('empty'));
                let trimmed_state = {};
                for (let [state_key, state_values] of enum_states){
                    trimmed_state[state_key] = entity_inst.state[state_key];
                }
                entity_inst.type.init_other_states(trimmed_state);
                for (let [state_key, state_values] of enum_states){
                    for (let v of state_values){
                        let new_state = structuredClone(trimmed_state);
                        new_state[state_key] = v;
                        selector_layer.next_entity_sublayer.swap(x, y, entity_inst.type, new_state);
                        x++;
                    }
                    y++
                }
                selector_layer.draw_all($selector_layer_cont);
            }
            redraw_hand_and_selector();

            let crafting_layer = new YardLayer(8, 5);

            let crafting_recipes = [
                {out: 'belt' ,in: [['iron_ingot', 6]]},
                {out: 'fast_belt' ,in: [['iron_ingot', 12], ['coal', 6]]},
                {out: 'faster_belt' ,in: [['iron_ingot', 24], ['lead_ingot', 1]]},
                {out: 'ladder' ,in: [['iron_ingot', 24]]},
                {out: 'router' ,in: [['iron_ingot', 12]]},
                {out: 'filter' ,in: [['iron_ingot', 12]]},
                {out: 'gravity_gen' ,in: [['iron_ingot', 24], ['coal', 12]]},
                {out: 'villager' ,in: [['coal', 12], ['food', 12]]},
                {out: 'stove' ,in: [['iron_ingot', 24], ['coal', 12]]},
                {out: 'steam_gen' ,in: [['iron_ingot', 24]]},
                {out: 'farm' ,in: [['food', 12]]},
                {out: 'magnifier' ,in: [['iron_ingot', 6], ['coal', 3]]},
                {out: 'lightbulb' ,in: [['iron_ingot', 6], ['coal', 3]]},
                {out: 'led' ,in: [['iron_ingot', 6], ['coal', 3], ['lead', 2]]},
                {out: 'elec_furnace' ,in: [['iron_ingot', 24], ['coal', 12]]},
                {out: 'uran_furnace' ,in: [['iron_ingot', 24], ['coal', 12]]},
                {out: 'battery' ,in: [['coal', 24]]},
                {out: 'nuclear_reactor' ,in: [['iron_ingot', 96], ['coal', 96], ['uran_ingot', 4]]},
                {out: 'nuclear_antireactor' ,in: [['iron_ingot', 96], ['coal', 96], ['uran_ingot', 4]]},
                {out: 'anitimatter_gen' ,in: [['iron_ingot', 144], ['coal', 144], ['uran_ingot', 12]]},
                {out: 'anitimatter_reactor' ,in: [['iron_ingot', 144], ['coal', 144], ['uran_ingot', 12]]},
                {out: 'wormhole_gen' ,in: [['iron_ingot', 144], ['coal', 144], ['uran_ingot', 12], ['anti_iron_ingot', 12]]},
                {out: 'wormhole_reactor' ,in: [['iron_ingot', 144], ['coal', 144], ['uran_ingot', 12], ['anti_iron_ingot', 12]]},
                {out: 'coin_maker' ,in: [['iron_ingot', 12], ['coal', 12]]},
                {out: 'drill' ,in: [['iron_ingot', 24]]},
                {out: 'uran_drill' ,in: [['iron_ingot', 24]]},
                {out: 'antimatter_enricher' ,in: [['iron_ingot', 144], ['coal', 144], ['lead', 12], ['anti_iron_ingot', 4]]},
                {out: 'wormhole_enricher' ,in: [['iron_ingot', 144], ['coal', 144], ['lead', 12], ['wormhole', 4]]},
                {out: 'store_food' ,in: [['iron_ingot', 6]]},
                {out: 'store_coal' ,in: [['iron_ingot', 6]]},
                {out: 'store_iron' ,in: [['iron_ingot', 6]]},
            ];
            let debug_crafting = global_debug;
            if (debug_crafting){
                crafting_layer = new YardLayer(8, 10);
                for (let [k, v] of entity_table){
                    crafting_recipes.push({
                        in: [],
                        out: k
                    });
                }
            }
            let crafting_recipes_positioned = new Map();

            let ground_crafting_region = {
                xa: 0, ya: 0, xb: 3, yb: 2
            }

            function get_default_state(entity_type){
                let state = {};
                for (let [state_key, values] of entity_type.enum_states()){
                    state[state_key] = values[0];
                }
                entity_type.init_other_states(state);
                return state;
            }

            function put_crafting(){
                let x = 0, y = 0;
                for (let recipe of crafting_recipes){
                    if (recipe.br){
                        y++;
                        continue;
                    }
                    crafting_recipes_positioned.set(crafting_layer.xy2i(x, y), recipe);
                    let out_type = entity_table.get(recipe.out);
                    crafting_layer.next_entity_sublayer.swap(x, y, out_type, get_default_state(out_type));
                    x++;
                    if (x >= crafting_layer.width){
                        y++;
                        x = 0;
                    }
                }
            }
            put_crafting();

            function can_craft(in_list, do_craft=false){
                let need_count = new Map();
                for (let [item_key, item_amount] of in_list){
                    need_count.set(item_table.get(item_key), item_amount);
                }
                for (let y=ground_crafting_region.ya; y<ground_crafting_region.yb; y++){
                    for (let x=ground_crafting_region.xa; x<ground_crafting_region.xb; x++){
                        let inst = ground_layer.next_item_sublayer.get_inst(x, y);
                        let [recipe_type, recipe_amount] = inst.type.as_crafting_ingredient(inst);
                        if (need_count.has(recipe_type)){
                            if (do_craft){
                                ground_layer.next_item_sublayer.swap(x, y, item_table.get('empty'), null);
                                ground_layer.set_item_changed(x, y, true);
                            }
                            let prev_amount = need_count.get(recipe_type);
                            if (prev_amount - recipe_amount < 0){ // too many ingredients in one item
                                continue;
                            }
                            need_count.set(recipe_type, prev_amount - recipe_amount);
                            if (need_count.get(recipe_type) == 0){
                                need_count.delete(recipe_type);
                                if (need_count.size == 0){
                                    return need_count;
                                }
                            }
                        }
                    }
                }
                return need_count;
            }

            crafting_layer.on_mouse_place_entity = function(inst){
                let i = inst.layer.xy2i(inst.x, inst.y);
                let recipe = crafting_recipes_positioned.get(i);
                if (!hand_has_space()){
                    return {able: false};
                }
                if (can_craft(recipe.in).size == 0){
                    can_craft(recipe.in, true);
                    let out_type = entity_table.get(recipe.out);
                    let state = get_default_state(out_type);
                    for (let [k, v] of Object.entries(state)){
                        if (selected_states.has(k)){
                            state[k] = selected_states.get(k);
                        }
                    }
                    hand_autoinsert(out_type, state);
                    redraw_hand_and_selector();
                }
                return {able: false};
            }

            let $crafting_cont = crafting_layer.make_cont(show_info, clear_and_show_hand);
            $('#crafting-cont').append($crafting_cont);
            crafting_layer.draw_all($crafting_cont);


            
            ground_layer.draw_all($layer_cont);
            let ikk = -1;
            $('body').append('<input type="text" id="spawn">');
            $('#advance').on('click', (e)=>{
                ikk = setInterval(()=>{
                    $("#time").text(ground_layer.time);
                    let to_spawn = $('#spawn').val();
                    if (item_table.has(to_spawn)){
                        ground_layer.next_item_sublayer.swap(0, 0, item_table.get(to_spawn), null);
                    }
                    ground_layer.tick_all();
                    ground_layer.draw_all($layer_cont);
                    underground_layer.tick_all();
                    underground_layer.draw_all($underground_layer_cont);
                }, 50);
            });
            $('#stop').on('click', (e)=>{
                clearInterval(ikk);
            });


            $underground_layer_cont.hide();
            let ground_visible = true;
            function update_ground_visibility(){
                if (ground_visible){
                    $layer_cont.show();
                    $underground_layer_cont.hide();
                } else {
                    $layer_cont.hide();
                    $underground_layer_cont.show();
                }
            }

            $('#flip-yard').on('mouseenter', (e)=>{
                $layer_cont.show();
                $underground_layer_cont.show();
                $layer_cont.css('opacity', 0.5);
                $underground_layer_cont.css('opacity', 0.5);
            });

            $('#flip-yard').on('mouseleave', (e)=>{
                $layer_cont.css('opacity', '');
                $underground_layer_cont.css('opacity', '');
                update_ground_visibility();
            });

            $('#flip-yard').on('click', (e)=>{
                ground_visible = !ground_visible;
                update_ground_visibility();
            });

        </script>
        <script>
            /*
            剧情：一个人特别爱六只马(pony)，这是他家的电表发生的变化……
                为了穿越到六马的世界，他读了很多书，发现要扭曲空间，需要很多能量。因此他开始搭建生产线，产出能量。
            类factorio：
                资源：
                    - 固态：粮食、饭、煤、铁矿、铀矿
                        铁、铀、铅
                        反铁
                    - 气态：
                        微虫洞
                        火、光、电
                机器：
                    - 物流
                        - （6铁/12铁6煤/24铁1铅）传送带（运送物品）
                        - （24铁）传送梯（跨层传送带）
                        - （12铁）路由器（随机分物品）
                        - （12铁）分类器（按类别分物品）
                        每种传送带有三阶，快中慢，快是1刻，中是3刻，慢是5刻。
                    - 能量转化
                        - 势能电池（50%效率）：抬升机放6电转化成基态（可以手动消耗饭激发）；村民消耗1饭，将旁边（4邻居）的抬升机激发1个(冷却时间约5s)
                        - 热能电池（37.5%效率）：炉子将1煤转化成9火，蒸汽机将2火转化成1电；大棚将12光转化成1粮食，1粮食在炉子转化成1饭，1饭在炉子转化成1煤
                        - 太阳能电池：放大镜把2光转化成1火；白炽灯把3电转化成期望值1光和2火，- LED灯把1电转化成1光
                        - 化学电池（83%效率）：电炉（消耗24电把1铁矿变24铁）+ 原电池（把24铁变1铁矿，产生20电）
                        - 可逆核过程电池（86%效率）：核反应堆把1铀变1铅，放144火，核子置入器把1铅变1铀，吸168火
                        - 反物质电池：光子对撞机吸144*4光和144*4火产生1铁和1反铁，两者在约束反应器中产生144*4光和136*4电
                        - 虫洞电池：时空界面消耗1728电和1728光产生微虫洞，微虫洞在反时空界面分解产生1728电和1680火

                    - 电动车充电（消耗6电，产生1圆钱，冷却6s）
                    - 钻头（挖矿）取决于位置，挖出铁矿、煤（1次挖24个）或1铀。消耗6电挖一格。铀是消耗6电和12铁
                    - 电炉（冶炼矿物）消耗24电把1铁矿变24铁，离心机消耗24电把1铀矿变3铀
                    - 反物质增殖装置：24反铁和6铅，75%概率变25反铁，25%概率变24反铁
                    - 宇宙际强力浓差虫洞增殖装置：12微虫洞和3反铁，75%概率变13微虫洞，25%概率变12微虫洞
                固定设施：
                    - 商店（购买饭（2圆），煤（3圆）、铁（3圆））
                    - 插座、电表：把钱输入电表，插座就可以出电（冷却时间长，1s出1电，1圆钱出12电）
                    - 太阳（产生光，1s随机地点产生12个光）
                世界场景：自己的家里面、院子（可以自由放东西的地图，有2层）/邻居、商店（只是可以交互的场景）/手（一格空间可以存物品）
                剧情邻居人物：赵犰狳、钱蝙蝠、孙骆驼、李蜻蜓、...

                短期TODO:
                    - [x] 鼠标指到物品上会隐藏
                    - [x] 动态实体描述
                    - 合成器、钻头等等实体的状态贴图或进度条
                    - 日夜循环，白天没太阳
                    - 只有下层能挖矿
                    - 商店不能动
                    - 电表插座
                    - 背景图
                    - 移动视角
                    - 放大缩小画面
                    - [x] 扩大物品栏面积

                DLC或更新：
                - 钻头效应变化
                    - 在同一格挖的时间越长，挖的时间越慢，消耗能量越多，收益越好，但总体是更不值的。
                - 买地
                    - 买邻居家的院子、地。实现为多个Layer实例组（需要封装），院子间只能传输物品不能传输能量。（暂时不可能实现）
                - 蒸汽机温度
                    - 加入火升温，随时间降温，升温时转化效率高。
                - 压缩与解压
                    - 打包机把6个（相同）资源压成包裹，装载机把6个包裹装成集装箱，卸载机和解包机相反
                    - 不能处理气态物体
                - 升压/降压器
                    - 将6个普通电变成中压电，将6个中压电变成高压电
                - 机械齿轮组
                    - 将6个普通功变成中力功，将6个中力功变成大力功
                - 重量传送带
                    - 每个物品的重量是1，打包后重量变重，机器打包时将包好的物品输出到前方，可以根据重量决定运走或者不走
                - 显卡（消耗电，产生算力）
                - 手机（消耗电，产生网络数据包）
                - 加密货币钱包（消耗算力和网络数据包，产生金钱）
                - 银行（兑换钱的面额）
                - 研究科技，计算机消耗算力还有网络数据包（还有材料？），可以研究科技，刚开始不用计算机，是拿煤做书读书
                - 水、重水、聚变发电机
                - 资源
                    炎、焱
                    废料（辣鸡）
                    智子
                    功
                - 机械能/齿轮放大做的功

            写得很烂能乱玩就可以了，千万不要尝试抽象，写什么类
            */
        </script>
    </body>
</html>
