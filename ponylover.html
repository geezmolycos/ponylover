<html>
    <head>
        <title>爱我的六色马可以做什么事</title>
        <meta charset="UTF-8">
	    <script
            src="https://code.jquery.com/jquery-3.6.0.min.js"
            integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4="
            crossorigin="anonymous"></script>
        <style>
            :root {
                --game-grid-size: 34px;
                --game-grid-border: 2px;
            }

            .layer-cont{
                position: relative;
            }
            .sublayer-cont{
                position: absolute;
                left: 0px;
                top: 0px;
            }
            .cell-wrapper{
                display: inline-block;
                width: var(--game-grid-size);
                height: var(--game-grid-size);
                box-sizing: border-box;
                padding-top: var(--game-grid-border);
                padding-left: var(--game-grid-border);
            }
            .grid-cont{
                border-bottom: var(--game-grid-border) solid black;
                border-right: var(--game-grid-border) solid black;
            }
            .grid-cont .cell-wrapper{
                border-top: var(--game-grid-border) solid black;
                border-left: var(--game-grid-border) solid black;
                padding-top: 0px;
                padding-left: 0px;
            }
        </style>
    </head>
    <body>
        <div>
            <button id="advance">advance</button>
            <button id="stop">stop</button>
            <span id="time">0</span>
        </div>
        <script>
            'use strict'

            const cardinal = [[0, -1], [-1, 0], [1, 0], [0, 1]];

            class EmptyEnt{
                can_place_item_on(inst){return true;}
                tick(inst){}
                draw(inst){}
                info(inst){}
                enum_states(){
                    return [];
                }
                init_other_states(state){}
            }

            function entity_dir_target(inst){
                let [dx, dy] = cardinal[inst.state.dir];
                let [tx, ty] = [inst.x + dx, inst.y + dy];
                return [tx, ty];
            }

            function entity_output_item(inst, item_type, item_state){
                let [tx, ty] = entity_dir_target(inst);
                if (inst.layer.item_sublayer.get_inst(tx, ty).type !== item_table.get('empty')
                    || inst.layer.get_item_changed(tx, ty)
                    || !inst.layer.can_place_item_on(tx, ty)){
                    return false;
                }
                inst.layer.next_item_sublayer.swap(tx, ty, item_type, item_state);
                inst.layer.set_item_changed(tx, ty, true);
                return true;
            }

            class BeltEnt{
                constructor(delay){
                    this.delay = delay;
                }
                can_place_item_on(inst){return true;}
                tick(inst){
                    if (inst.layer.time % this.delay != 0){
                        return;
                    }
                    //console.log(inst.x, inst.y);
                    if (inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                    if (entity_output_item(inst, old_item_inst.type, old_item_inst.state)){
                        inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                        inst.layer.set_item_changed(inst.x, inst.y, true);
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('./belt.png')`)
                        .css('background-size', '100% 100%')
                        .css('width', '100%')
                        .css('height', '100%')
                        .css('transform', `rotate(${rotation})`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){}
            }

            class MachineEnt{
                constructor(ingredient_f, amounts, product_type, product_state){
                    this.ingredient_f = ingredient_f;
                    this.amounts = amounts;
                    this.product_type = product_type;
                    this.product_state = product_state;
                }
                can_place_item_on(inst){return true;}
                check_fulfill(inst){
                    if (inst.state.fulfilled){
                        return true;
                    }
                    let fulfilled = true;
                    $.each(this.amounts, (i, val) => {
                        if (inst.state.current_amounts[i] < val){
                            fulfilled = false;
                            return false;
                        }
                    });
                    return fulfilled;
                }
                tick(inst){
                    if (inst.layer.get_item_changed(inst.x, inst.y)
                        || inst.layer.item_sublayer.get_inst(inst.x, inst.y).type === item_table.get('empty')){
                        return;
                    }
                    let ingredient_i = this.ingredient_f(
                        inst.layer.item_sublayer.get_inst(inst.x, inst.y).type,
                        inst.layer.item_sublayer.get_inst(inst.x, inst.y).state
                    )
                    if (ingredient_i === -1){
                        if (inst.layer.time % 5 != 0){
                            return;
                        }
                        let old_item_inst = inst.layer.item_sublayer.get_inst(inst.x, inst.y);
                        if (entity_output_item(inst, old_item_inst.type, old_item_inst.state)){
                            inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                            inst.layer.set_item_changed(inst.x, inst.y, true);
                        }
                        return;
                    }
                    inst.state.current_amounts[ingredient_i]++;
                    inst.layer.next_item_sublayer.swap(inst.x, inst.y, item_table.get('empty'), null);
                    inst.layer.set_item_changed(inst.x, inst.y, true);
                    if (this.check_fulfill(inst)){
                        inst.state.fulfilled = true;
                        if (entity_output_item(inst, this.product_type, this.product_state)){
                            this.init_other_states(inst.state);
                        }
                    }
                }
                draw(inst){
                    let rotation = ['0deg', '270deg', '90deg', '180deg'][inst.state.dir];
                    return $('<div>')
                        .css('background-image', `url('./gen.png')`)
                        .css('background-size', '100% 100%')
                        .css('width', '100%')
                        .css('height', '100%')
                        .css('transform', `rotate(${rotation})`);
                }
                info(inst){}
                enum_states(){
                    return [
                        ['dir', [0,1,2,3]],
                    ];
                }
                init_other_states(state){
                    state.fulfilled = false;
                    state.current_amounts = new Array(this.amounts.length).fill(0);
                }
            }

            class EmptyItem{
                draw(inst){}
                info(inst){}
            }

            class IconItem{
                constructor(icon){
                    this.icon = icon;
                }
                draw(inst){
                    return $('<div>')
                        .css('background-image', `url('${this.icon}')`)
                        .css('background-size', '100% 100%')
                        .css('width', '100%').css('height', '100%');
                }
                info(inst){}
            }

            let item_table = new Map([
                ['empty', new EmptyItem()],
                ['iron', new IconItem("./iron.png")],
                ['elec', new IconItem("./elec.png")],
            ]);

            let entity_table = new Map([
                ['empty', new EmptyEnt()],
                ['belt', new BeltEnt(5)],
                ['gen', new MachineEnt((type, state)=>(type == item_table.get('iron') ? 0 : -1), [3], item_table.get('elec'), null)],
            ]);

            class YardSubLayer{
                constructor(layer, init_val){
                    this.layer = layer;
                    this.type = new Array(this.layer.width * this.layer.height).fill(init_val);
                    this.state = new Map();
                }

                swap(x, y, new_type, new_state){
                    const i = this.layer.xy2i(x, y);
                    const old_type = this.type[i];
                    const old_state = this.state.get(i) || null;
                    this.state.delete(i);
                    this.type[i] = new_type;
                    if (new_state !== null){
                        this.state.set(i, new_state);
                    }
                    return [old_type, old_state];
                }

                make_cont(){
                    let $sublayer_cont = $('<div>').addClass('sublayer-cont');
                    for (let y=0; y<this.layer.height; y++){
                        for (let x=0; x<this.layer.width; x++){
                            const wrapper = $('<div>').addClass('cell-wrapper').data('x', x).data('y', y);
                            $sublayer_cont.append(wrapper);
                        }
                        $sublayer_cont.append($('<br>'));
                    }
                    return $sublayer_cont;
                }

                get_inst(x, y){
                    let state = this.state.get(this.layer.xy2i(x, y)) || null;
                    let type = this.type[this.layer.xy2i(x, y)];
                    return {
                        layer: this.layer,
                        x: x,
                        y: y,
                        type: type,
                        state: state,
                    }
                }

                draw_all($sublayer_cont){
                    let that = this;
                    $sublayer_cont.children('.cell-wrapper').each((_, wrapper)=>{
                        let $wrapper = $(wrapper);
                        const x = $wrapper.data('x');
                        const y = $wrapper.data('y');
                        $wrapper.empty();
                        let inst = that.get_inst(x, y);
                        let c = inst.type.draw(inst);
                        $wrapper.append(c);
                    });
                }
            }

            class YardLayer{
                constructor(width, height){
                    this.width = width;
                    this.height = height;
                    this.entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.next_entity_sublayer = new YardSubLayer(this, entity_table.get('empty'));
                    this.entity_changed = new Array(this.width * this.height).fill(false);
                    this.item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.next_item_sublayer = new YardSubLayer(this, item_table.get('empty'));
                    this.item_changed = new Array(this.width * this.height).fill(false);
                    this.time = 0;
                }

                get_entity_changed(x, y){
                    return this.entity_changed[this.xy2i(x, y)];
                }
                
                set_entity_changed(x, y, val){
                    this.entity_changed[this.xy2i(x, y)] = val;
                }

                get_item_changed(x, y){
                    return this.item_changed[this.xy2i(x, y)];
                }

                set_item_changed(x, y, val){
                    this.item_changed[this.xy2i(x, y)] = val;
                }

                can_place_item_on(x, y){
                    if (!this.is_in_border(x, y)){
                        return false;
                    }
                    let inst = this.entity_sublayer.get_inst(x, y);
                    let ninst = this.next_entity_sublayer.get_inst(x, y);
                    return inst.type.can_place_item_on(inst) && ninst.type.can_place_item_on(ninst);
                }

                xy2i(x, y){
                    return this.width * y + x;
                }

                i2xy(i){
                    return [i % this.width, Math.floor(i / this.width)];
                }

                is_in_border(x, y){
                    return 0 <= x && x < this.width && 0 <= y && y < this.height;
                }

                do_tick_reversed(){
                    return this.time % 4 < 2;
                }

                tick_all(){
                    if (this.do_tick_reversed()){
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(this.width - x - 1, this.height - y - 1);
                            }
                        }
                    } else {
                        for (let y=0; y<this.height; y++){
                            for (let x=0; x<this.width; x++){
                                this.tick_at(x, y);
                            }
                        }
                    }
                    this.item_sublayer.type = [...this.next_item_sublayer.type];
                    this.item_sublayer.state = new Map(this.next_item_sublayer.state);
                    this.item_changed.fill(false);
                    this.entity_sublayer.type = [...this.next_entity_sublayer.type];
                    this.entity_sublayer.state = new Map(this.next_entity_sublayer.state);
                    this.entity_changed.fill(false);
                    this.time++;
                }

                tick_at(x, y){
                    let inst = this.entity_sublayer.get_inst(x, y);
                    inst.type.tick(inst);
                }

                make_cont(){
                    let $cont = $('<div>').addClass('layer-cont');
                    let $grid_cont = this.entity_sublayer.make_cont().addClass('grid-cont');
                    let $entity_cont = this.entity_sublayer.make_cont().addClass('entity-sublayer-cont');
                    let $item_cont = this.item_sublayer.make_cont().addClass('item-sublayer-cont');
                    let $mouseclick_cont = this.entity_sublayer.make_cont().addClass('mouseclick-cont');
                    $mouseclick_cont.children('.cell-wrapper').on('click', (e)=>{
                        let x = $(this).data('x');
                        let y = $(this).data('y');
                        // TODO
                    });
                    $cont.append($grid_cont).append($entity_cont).append($item_cont);
                    return $cont;
                }

                draw_all($layer_cont){
                    let $entity_cont = $layer_cont.children('.entity-sublayer-cont');
                    let $item_cont = $layer_cont.children('.item-sublayer-cont');
                    this.entity_sublayer.draw_all($entity_cont);
                    this.item_sublayer.draw_all($item_cont);
                }
            }
        
        let yl = new YardLayer(5, 5);
        
        let $layer_cont = yl.make_cont();
        $('body').append($layer_cont);
        yl.next_item_sublayer.swap(1, 0, item_table.get('iron'), null);
        yl.next_item_sublayer.swap(1, 1, item_table.get('iron'), null);
        yl.next_item_sublayer.swap(0, 2, item_table.get('elec'), null);
        yl.next_item_sublayer.swap(1, 2, item_table.get('iron'), null);
        yl.next_item_sublayer.swap(1, 3, item_table.get('iron'), null);
        yl.next_item_sublayer.swap(1, 4, item_table.get('iron'), null);
        yl.next_entity_sublayer.swap(1, 0, entity_table.get('belt'), {dir: 3});
        yl.next_entity_sublayer.swap(1, 1, entity_table.get('belt'), {dir: 3});
        yl.next_entity_sublayer.swap(0, 2, entity_table.get('belt'), {dir: 2});
        yl.next_entity_sublayer.swap(1, 3, entity_table.get('belt'), {dir: 0});
        yl.next_entity_sublayer.swap(1, 4, entity_table.get('belt'), {dir: 0});
        yl.next_entity_sublayer.swap(1, 2, entity_table.get('belt'), {dir: 2});
        yl.next_entity_sublayer.swap(2, 2, entity_table.get('belt'), {dir: 2});
        yl.next_entity_sublayer.swap(3, 2, entity_table.get('gen'), {dir: 2});
        let bi = yl.next_entity_sublayer.get_inst(3, 2)
        bi.type.init_other_states(bi.state);
        yl.next_entity_sublayer.swap(4, 2, entity_table.get('belt'), {dir: 3});
        yl.next_entity_sublayer.swap(4, 3, entity_table.get('belt'), {dir: 3});
        yl.tick_all();
        yl.draw_all($layer_cont);
        let ikk = -1;
        $('#advance').on('click', (e)=>{
            ikk = setInterval(()=>{
                $("#time").text(yl.time);
                yl.tick_all();
                yl.draw_all($layer_cont);
            }, 50);
        });
        $('#stop').on('click', (e)=>{
            clearInterval(ikk);
        });
        </script>
        <script>
            /*
            剧情：一个人特别爱六只马(pony)，这是他家的电表发生的变化……
                为了穿越到六马的世界，他读了很多书，发现要扭曲空间，需要很多能量。因此他开始搭建生产线，产出能量。
            类factorio：
                能量发展线：
                    ->人力(要耗饭)/市电(需要付钱)（插口有限）
                    ->村里大爷大妈人力(要耗饭)
                    ->太阳能(一次投入的钱多，产出的少，但是后面免费)/火力发电(用煤炉子改的，要付煤费，可以顺便产出饭)
                    ->自己采煤发电/地热发电
                    ->核能发电（聚变发电）
                    ->真空零点能发电
                    ->宇宙际强相互力梯度差势发电（反向向里面传能量就可以完成游戏目标）
                资源：
                    粮食、饭、煤、铁矿、石、铀矿、水、重水
                    铁、铀、铅
                    反铁
                    微虫洞
                    火（炎、焱）光、电
                    （废料（辣鸡）
                    （智子
                机器：
                    - 物流
                        - 传送带（运送物品）
                        - 传送梯（跨层传送带）
                        - 路由器（随机分物品）
                        - 分类器（按类别分物品）
                    - 能量转化
                        - 势能电池：抬升机消耗电转化成激发态，放电转化成基态（可以手动消耗饭激发）；村民消耗饭，将旁边的抬升机激发
                        - 热能发电：炉子将煤转化成火，蒸汽机将火转化成电；大棚将光转化成粮食，粮食在炉子转化成饭，饭在炉子转化成煤
                        - 太阳能电池：把光转化成火；LED灯把电转化成光
                        - 化学电池：电炉（消耗电把铁矿变铁）+ 原电池（把铁变铁矿，产生电）
                        - 可逆核过程电池：核反应堆把铀变铅，放能，核子置入器把铅变铀，吸能
                        - 反物质电池：光子对撞机吸能产生铁和反铁，两者在约束反应器中产生能量
                        - 虫洞电池：时空界面消耗能量产生微虫洞，微虫洞在时空界面分解产生能量
                    - （变压器：转换电压
                    - 电动车充电（消耗电，产生金钱）
                    - （显卡（消耗电，产生算力）
                    - （手机（消耗电，产生网络数据包）
                    - （加密货币钱包（消耗算力和网络数据包，产生金钱）
                    - 电炉（冶炼矿物）
                    - （银行（兑换钱的面额）
                    - （研究科技，计算机消耗算力还有网络数据包（还有材料？），可以研究科技，刚开始不用计算机，是拿煤做书读书
                    - 钻头（挖矿）
                    - 水泵（挖水，提取重水）
                    - 机械能/齿轮放大做的功
                固定设施：
                    - 商店（购买粮食，煤、铁、石）
                    - 插座、电表：把钱输入电表，插座就可以出电
                    - 太阳（产生光）
                    - 田地（输入光产生粮食）
                世界场景：自己的家里面、院子（可以自由放东西的地图，有2层）/邻居、商店（只是可以交互的场景）/手（一格空间可以存物品）
                有的属性：金钱（元）、饥饿值、时间（白天黑夜、星期）
                剧情邻居人物：赵犰狳、钱蝙蝠、孙骆驼、李蜻蜓、...

            写得很烂能乱玩就可以了，千万不要尝试抽象，写什么类
            */
        </script>
    </body>
</html>
